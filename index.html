<!DOCTYPE html>
<script>
    // Welcome to my single-file webapp, Telegram Timeline!
    // Written by Torivd and ChatGPT.
    // I'm not a web developer by trade. Hopefully I didn't fuck up any security stuff. :)

    // TODO:
    // Add tooltips to everything
    // Add suppor tfor Posting messages to a custom channel
    // viewing a single channel
        // Loading channel description, etc
    // "share" button that works
    // Add meta-tags with some nice marketing images

    // Lightbox forimages
    // Arbitrary file download?
    // Download button for files

    // TODO: add support for removing/inserting messages as they come in

    // TODO: add DMs in the bottom right

    // TODO: add a list of everyone you currently follow
    //  Maybe have it ask your interests? (memes, furry, cars, food/cooking, etc)

    // TODO: make it so posts are cleverly fintered such that channels that spam a lot show up less

</script>
<!--
teletime.net

    Now that twitter has no discoverability anymore, we could just move to telegram. :)
    This telegram client takes all the channels you follow and puts them into a single feed.
    Tell me what you think, Poke @Torvid with thoughts and ideas. Especially if you are an experienced web developer <3.

    The whole website is a single ~2kLOC html file containing all the html/css/script, so it should be easy for anyone to audit.
    Only external library is TDweb, a wrapper for the telegram API found here:
    https://www.npmjs.com/package/tdweb

    LIVE version is here: https://teletime.net/
    DEV version is here: http://212.100.102.124:8000/

Let's turn telegram into twitter
Want to escape twitter?
Already use telegram?

This web client takes all the telegram channels you follow and puts them into a single feed.

You can comment, like and retweet (forward) just like on twitter!

:)

[login thingy]

For the techy people,
This is app written in pure JS using TDweb, and is hosted statically on github.io here: [link]

something something preocupied with whether they could

-->

<style>
    /*css to make it look like some terrible amalgum of telegram and twitter.*/

    body {
        background-color: #0E1621;
        color: #FFFFFF;
        font-family: 'Atkinson Hyperlegible', sans-serif; /*I like this font, open to changes though.*/
        font-style: normal;
    }

    /* needed for the hidden attribute to actually work lol */
    [hidden] {
        display: none !important;
    }

    message {
        background-color: #182533;
        display: block;
        margin: 1em;
        border-radius: 1em;
        width: 37em;
        padding: 0.5em;
        height: 50%;
    }

    message-caption {
        display: block;
        padding: 0.5em;
        white-space: break-spaces;
    }

    message-title {
    }


    message message-profile img {
        width: 4em;
        height: 4em;
        border-radius: 4em;
    }

    message message-profile span {
        position: relative;
        top: -3.0em;
        left: 0.5em;
        padding: 0.5em;
        color: #72BAFA;
        font-weight: Bold;
    }

    message-profile {
        display: block;
    }

    message-content {
        left: 4.5em;
        top: -3em;
        position: relative;
        max-width: 30em;
        display: block;
    }

    message-timestamp {
        text-align: right;
        display: block;
        padding: 0.5em;
        font-size: small;
        color: #71767B;
    }

    message-interactions {
        margin: 2em;
        position: relative;
        top: 0em;
        left: -6em;
        white-space: nowrap;
        display: inline;
    }

    message-images {
        padding-right: 6em;
        display: grid;
        grid-template-columns: repeat(2, 1fr);
    }

        message-images img {
            margin: 0.1em;
            border-radius: 1em;
            width: 100%;
        }

        message-images video {
            border-radius: 1em;
            width: 100%;
        }

        message-images progress {
            width: 100%;
            display: block;
        }

        message-images img:nth-child(1) {
            grid-column: 1 / 3;
        }

        message-images video:nth-child(1) {
            grid-column: 1 / 3;
        }

    button {
        background-color: #182533;
        border: none;
        color: white;
        width: 7em;
        position: relative;
        display: inline;
    }

        button span {
            position: absolute;
            top: 0.7em;
            left: 6.5em;
        }
        /* after has background color that changes on hover */
        /* before has the icon. */
        button:hover::before {
            background-color: #40678b;
        }

        button::before {
            content: "";
            background-size: 2.5em 2.5em;
            background-repeat: no-repeat;
            background-position: center;
            width: 2.5em;
            height: 2.5em;
            position: absolute;
            transition: background-color 0.1s;
            border-radius: 2em;
        }

        button::after {
            content: "";
            background-image: url('icon-reply.png');
            background-size: 1.5em 1.5em;
            background-repeat: no-repeat;
            background-position: center;
            width: 2.5em;
            height: 2.5em;
            position: absolute;
        }

    .reply::after {
        background-image: url('icon-reply.png');
    }

    .retweet::after {
        background-image: url('icon-retweet.png');
    }

    .like::after {
        background-image: url('icon-like.png');
    }

    .views::after {
        background-image: url('icon-views.png');
    }

    .share::after {
        background-image: url('icon-share.png');
    }
    .messageInput {
        display: flex;
        flex-direction: row;
        align-items: flex-start; /* Aligns the items vertically */
        gap: 10px; /* Optional: Adds space between the textarea and the button */
    }
    #messageTextbox {
        width: 38em;
        min-height: 4em; /* Adjust the height as needed */
        resize: vertical; /* Allows vertical resizing of the textarea */
    }
    #messageSendButton {
        width:5em;
        height: 4em;
        /* display: inline-block; */
        /* position: relative; */
    }
</style>

<head>
</head>

<body>
    <h1>Telegram Timeline</h1>

    <div style="white-space: break-spaces;">
        this is going to be crazy lol
        watch this space
        indev!
    </div>

    <div id="status">
        <p id="state">state: </p>
        <p id="auth_state">auth_state: </p>
        <p id="user_id">user_id: </p>
    </div>


    <div id="phoneVerify">
        <label for="phone">Enter phone number:</label>
        <input type="tel" id="phoneNumber" name="phone">
        <input type="button" id="phoneButton" value="ok">
        <br />
        You need to use the regional indicator (+46xxxx...)
    </div>

    <div id="codeVerify">
        <label for="phone">Enter login code:</label>
        <input type="tel" id="codeNumber" name="phone">
        <input type="button" id="codeButton" value="ok">
    </div>

    <div id="mainView">
        <span>write a message!</span>
        <br />
        
        <div class="messageInput">
            <textarea id="messageTextbox"></textarea>
            <input type="button" id="messageSendButton" value="send">
        </div>

        <p id="channelList">
        </p>

    </div>
</body>

<!-- Telegram library-->
<script src="tdweb.js"></script>

<script>
    'use strict'; // first we use strict, because hoisting is unbased

    // then some utility functions
    // from here - https://www.npmjs.com/package/last-seen-ago?activeTab=readme
    function getNiceTime(date)
    {
        var currentTime = Math.floor(Date.now() / 1000) // timestamp in seconds
        var differenceTime = currentTime - Math.floor(date / 1000);
        var seconds = differenceTime;
        var minutes = Math.floor(seconds / 60);
        var hours = Math.floor(seconds / 3600);
        var days = Math.floor(seconds / 86400);
        var weeks = Math.floor(seconds / 604800);
        var months = Math.floor(seconds / 2629440);
        var years = Math.floor(seconds / 31553280);

        if (seconds <= 60)
        {
            return "Just Now";
        }
        else if (minutes <= 60)
        {
            if (minutes == 1) return "one minute ago";
            else return `${minutes} minutes ago`;
        }
        else if (hours <= 24)
        {
            if (hours == 1) return "an hour ago";
            else return `${hours} hrs ago`;
        }
        else if (days <= 7)
        {
            if (days == 1) return "yesterday";
            else return `${days} days ago`;
        }
        else if (weeks <= 4.3)
        {
            if (weeks == 1) return "a week ago";
            else return `${weeks} weeks ago`;
        }
        else if (months <= 12)
        {
            if (months == 1) return "a month ago";
            else return `${months} months ago`;
        }
        else
        {
            if (years == 1) return "one year ago";
            else return `${years} years ago`;
        }
    }

    // copied from stackoverflow, "wait for input"
    // https://stackoverflow.com/questions/51374649/using-async-functions-to-await-user-input-from-onclick
    function waitListener(element, listenerName)
    {
        return new Promise(function (resolve, reject)
        {
            var listener = event =>
            {
                element.removeEventListener(listenerName, listener);
                resolve(event);
            };
            element.addEventListener(listenerName, listener);
        });
    }

    // some global variables :)
    var channelIDs = []
    var loadedMessages = [] // groups messages into albums
    var allMessages = [] // does not group messages into albums
    var channels = {}
    var user = undefined; // current user
    var timelineChannel = undefined // your timeline channel

    // get html elements
    var DOMlogState = document.getElementById("state");
    var DOMlogStateAuth = document.getElementById("auth_state");
    var DOMlogUserID = document.getElementById("user_id");

    var DOMphoneVerify = document.getElementById("phoneVerify");
    var DOMphoneButton = document.getElementById("phoneButton");
    var DOMphoneNumber = document.getElementById("phoneNumber");
    DOMphoneVerify.hidden = true;

    var DOMcodeVerify = document.getElementById("codeVerify");
    var DOMcodeButton = document.getElementById("codeButton");
    var DOMcodeNumber = document.getElementById("codeNumber");
    DOMcodeVerify.hidden = true;

    var DOMmainView = document.getElementById("mainView");
    var DOMtestButton = document.getElementById("testButton");
    var DOMchannelList = document.getElementById("channelList");
    var DOMmessageSendButton = document.getElementById("messageSendButton");
    var DOMmessageTextbox = document.getElementById("messageTextbox");
    DOMmainView.hidden = true;

    DOMmessageSendButton.addEventListener("click", function ()
    {
        sendMessage();
    });

    DOMmessageTextbox.addEventListener("keydown", function (event)
    {
        if (event.shiftKey)
            return;
        if (event.ctrlKey)
            return;
        if (event.key === "Enter")
        {
            event.preventDefault();

            sendMessage();
        }
    });

    var scrollChecker = setInterval(function ()
    {
        scroll = document.body.offsetHeight - (window.innerHeight + Math.ceil(window.pageYOffset));
        if (scroll < 500)
        {
            loadMore();
        }
    }, 1000);

    async function sendMessage()
    {
        if (DOMmessageTextbox.value == "")
            return;

        // channel not found yet, create it!
        if (!timelineChannel)
        {
            // create the channel
            const chat = await client.send({
                "@type": "createNewSupergroupChat",
                title: user.username + "'s Telegram Timeline",
                is_channel: true,
                description: "This channel is your Timeline. \nMessages posted or retweeted on from teletime.net will show up here. \n\nThis last number is your user ID and needs to remain at the end of the description for Teletime to work correctly.\nIf you want to use a different channel as your timeline, move this number to the end of that channels description.\n" + user.id,
            });
            var chatId = chat.id;

            var public_username = user.username + "_Timeline4";

            // make it public 
            const isUsernameAvailable = await client.send({
                "@type": "checkChatUsername",
                chat_id: chatId,
                username: public_username,
            });

            if (!isUsernameAvailable)
            {
                // TODO: handle this more gracefully. try again a bunch of times with alernate names?
                console.log("failed to make the channel public. PANIC.");
                return;
            }

            // don't wait for this
            client.send({
                "@type": "setSupergroupUsername",
                supergroup_id: chat.type.supergroup_id,
                username: public_username,
            });

            timelineChannel = chat;
            // change the profile pic
            // TODO: figure out how to set the profile picture.

            //const uniqueRemoteImageUrl = `$http://212.100.102.124:8000/Coal.png?${Date.now()}`;
            //console.log(uniqueRemoteImageUrl);
            //var setphotoresult = await client.send({
            //    "@type": "setChatPhoto",
            //    chat_id: chatId,
            //    photo: {
            //        "@type": "inputFileGenerated",
            //        original_path: uniqueRemoteImageUrl,
            //        conversion: "",
            //        expected_size: 0,
            //    },
            //});
            //console.log(setphotoresult);
        }

        // Send a text message to the channel
        const result = await client.send({
            "@type": "sendMessage",
            chat_id: timelineChannel.id,
            input_message_content: {
                "@type": "inputMessageText",
                text: {
                    "@type": "formattedText",
                    text: DOMmessageTextbox.value,
                },
                disable_web_page_preview: false,
                clear_draft: true,
            },
        });

        DOMmessageTextbox.value = "";
        addMessage(timelineChannel.id, result, timelineChannel.title);
    }


    function MakeRetweetFunction(inner_id, inner_chatId)
    {
        return async function()
        {
            var fwd = loadedMessages[inner_id].messages;
            var msgs = [];
            for (var i = 0; i < fwd.length; i++)
            {
                msgs.push(fwd[i].id)
            }
            client.send({
                '@type': 'forwardMessages',
                from_chat_id: inner_chatId,
                chat_id: timelineChannel.id,
                message_ids: msgs,
            });
        }
    }

    // Creates a message and appends it to the DOM
    function createMessage(id, chatId, username, message)
    {
        var date = message.date;
        var forwardcount = message.interaction_info.forward_count;
        var viewcount = message.interaction_info.view_count;

        loadedMessages[id] = {};
        if (loadedMessages[id].messages == undefined)
            loadedMessages[id].messages = []
        loadedMessages[id].messages.push(message);

        var firstChildThatIsOlderThanNewMessage = undefined
        for (const child of DOMchannelList.children)
        {
            if (date > child.getAttribute("timestamp"))
            {
                firstChildThatIsOlderThanNewMessage = child
                break;
            }
        }

        var DOMmessage = document.createElement("message");

        if (firstChildThatIsOlderThanNewMessage)
        {
            DOMchannelList.insertBefore(DOMmessage, firstChildThatIsOlderThanNewMessage);
        }
        else
        {
            DOMchannelList.appendChild(DOMmessage);
        }

        if (channels[chatId].latestDOMmessage)
            channels[chatId].latestDOMmessage.hidden = false;

        DOMmessage.hidden = true;

        channels[chatId].latestDOMmessage = DOMmessage;
        loadedMessages[id].DOMmessage = DOMmessage;

        DOMmessage.setAttribute("timestamp", date)

        loadedMessages[id].DOMprofile = loadedMessages[id].DOMmessage.appendChild(document.createElement("message-profile"));
        loadedMessages[id].DOMprofileImg = loadedMessages[id].DOMprofile.appendChild(document.createElement("img"));
        loadedMessages[id].DOMprofileUsername = loadedMessages[id].DOMprofile.appendChild(document.createElement("span"));

        loadedMessages[id].DOMcontent = loadedMessages[id].DOMmessage.appendChild(document.createElement("message-content"));
        loadedMessages[id].DOMcaption = loadedMessages[id].DOMcontent.appendChild(document.createElement("message-caption"));
        loadedMessages[id].DOMimages = loadedMessages[id].DOMcontent.appendChild(document.createElement("message-images"));
        loadedMessages[id].DOMinteractions = loadedMessages[id].DOMcontent.appendChild(document.createElement("message-interactions"));

        loadedMessages[id].DOMreply = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        loadedMessages[id].DOMreply.setAttribute("class", "reply");
        loadedMessages[id].DOMreplyText = loadedMessages[id].DOMreply.appendChild(document.createElement("span"))
        loadedMessages[id].DOMreplyText.textContent = 0;

        loadedMessages[id].DOMretweet = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        loadedMessages[id].DOMretweet.setAttribute("class", "retweet");
        loadedMessages[id].DOMretweet.appendChild(document.createElement("span")).textContent = forwardcount;

        

        loadedMessages[id].DOMretweet.addEventListener("click", MakeRetweetFunction(id, chatId));


        var DOMviews = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        DOMviews.setAttribute("class", "views");
        DOMviews.appendChild(document.createElement("span")).textContent = viewcount;

        var DOMshare = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        DOMshare.setAttribute("class", "share");
        DOMshare.appendChild(document.createElement("span")).textContent = ""

        loadedMessages[id].DOMtimestamp = DOMmessage.appendChild(document.createElement("message-timestamp"));

        loadedMessages[id].DOMprofileImg.src = channels[chatId].profilePicture;
        loadedMessages[id].DOMprofileUsername.textContent = username
        loadedMessages[id].DOMtimestamp.textContent = getNiceTime(new Date(date * 1000));
    }

    async function loadMore()
    {
        if (!doneLoading)
            return;

        for (var j = 0; j < 5; j++)
        {
            var smallest = undefined;
            var smallestTimestamp = 0;
            var smallestID = 0;
            // find the channel with the most recent message and load that one
            for (var i = 0; i < Object.keys(channels).length; i++)
            {
                var channel = channels[Object.keys(channels)[i]];
                if (channel.exhausted)
                    continue;

                var timestamp = channel.latestMessageTimestamp
                if (timestamp > smallestTimestamp)
                {
                    smallestTimestamp = timestamp
                    smallest = channel;
                    smallestID = Object.keys(channels)[i];
                }
            }

            await loadMessageFromChannel(smallestID, smallest.title)
        }
    }

    async function loadImage(file)
    {
        return loadFile(file, "image/png", null);
    }
    async function loadFileBlob(file, mime_type, setProgress)
    {
        // TODO: add support for streaming large video files.

        const CHUNK_SIZE = 1024 * 64; // 64KB

        let offset = 0;
        let fileSize = file.size;

        const chunks = [];
        while (true)
        {
            var DLSize = Math.min(CHUNK_SIZE, fileSize - offset)

            if (DLSize <= 0)
                break;

            if (!file.is_downloading_completed)
            {
                var result = await client.send({
                    '@type': 'downloadFile',
                    file_id: file.id,
                    priority: 1,
                    offset: offset, // where in the file to start downloading
                    limit: DLSize, // how much to download in bytes
                    synchronous: true, // download the file synchronously
                });
            }

            const result2 = await client.send({
                '@type': 'readFilePart',
                file_id: file.id,
                offset: offset,
                count: Math.min(CHUNK_SIZE, fileSize - offset),
            });

            const fileData = result2.data;
            chunks.push(fileData);

            if (setProgress)
                setProgress(offset, fileSize);

            offset += CHUNK_SIZE;
        }
        const blob = new Blob(chunks, { type: mime_type });
        if (setProgress)
            setProgress(fileSize, fileSize);

        return blob;
    }
    async function loadFile(file, mime_type, setProgress)
    {
        const blob = await loadFileBlob(file, mime_type, setProgress)
        return URL.createObjectURL(blob);
    }
    async function setReplyCount(id, message)
    {
        if (loadedMessages[id].DOMreplyText.textContent == 0 && message.interaction_info.reply_info)
            loadedMessages[id].DOMreplyText.textContent = message.interaction_info.reply_info.reply_count;
    }
    async function addImage(id, message, image)
    {
        var images = loadedMessages[id].DOMimages;

        var img = document.createElement('img');

        images.insertBefore(img, images.firstChild);

        loadImage(image).then((src) =>
        {
            img.src = src;
        })
        return img;
    }
    async function addVideo(id, message, video, thumbnail, controls)
    {
        var thumbnailPath = await loadImage(thumbnail);
        var DOMvideo = document.createElement('video');
        var images = loadedMessages[id].DOMimages;
        images.insertBefore(DOMvideo, images.firstChild);

        if (controls)
        {
            DOMvideo.setAttribute("controls", "");
        }
        else
        {
            DOMvideo.setAttribute("autoplay", "");
            DOMvideo.setAttribute("loop", "");
        }

        DOMvideo.setAttribute("poster", thumbnailPath);

        var progress = images.appendChild(document.createElement('progress'));
        var videoUrl = await loadFile(video, "video/mp4", function (value, max)
        {
            if (value == max) // done
            {
                progress.hidden = true;
            }
            progress.setAttribute("value", value)
            progress.setAttribute("max", max)
        });

        var source = document.createElement('source');
        source.setAttribute("src", videoUrl);
        DOMvideo.appendChild(source);
    }
    async function setCaption(id, message, caption)
    {
        if (loadedMessages[id].DOMcaption.textContent == "")
            loadedMessages[id].DOMcaption.textContent = caption;
    }

    // high level function to download and add a message to the timeline.
    async function addMessage(chatId, message, chatTitle)
    {
        // not the nicest solution.
        // problem where messages would duplicate if loadMessageFromChannel gets called in a spammy manner.
        // maybe if the function waited until latestMessage got updated?
        // TODO: look into more elegant solution. For now this works.
        if (message.id in allMessages) // we got the same message twice. reject it!
            return;

        allMessages[message.id] = {};

        var id = message.media_album_id;
        if (message.media_album_id == 0)
            id = message.id;

        channels[chatId].latestMessage = message.id;
        channels[chatId].loadedMessageCount++;
        channels[chatId].latestMessageTimestamp = message.date;

        var contentType = message.content["@type"];
        if (contentType == "messageText")
        {
            if (!(id in loadedMessages)) // new message
                createMessage(id, chatId, chatTitle, message);
            await setReplyCount(id, message);
            await setCaption(id, message, message.content.text.text);
        }
        else if (contentType == "messagePhoto")
        {
            if (!(id in loadedMessages)) // new message
                createMessage(id, chatId, chatTitle, message)
            await setReplyCount(id, message);
            await setCaption(id, message, message.content.caption.text);
            await addImage(id, message, message.content.photo.sizes[0].photo);
        }
        else if (contentType == "messageVideo")
        {
            if (!(id in loadedMessages)) // new message
                createMessage(id, chatId, chatTitle, message)
            await setReplyCount(id, message);
            await setCaption(id, message, message.content.caption.text);
            await addVideo(id, message, message.content.video.video, message.content.video.thumbnail.file, true)
        }
        else if (contentType == "messageAnimation")
        {
            if (!(id in loadedMessages)) // new message
                createMessage(id, chatId, chatTitle, message)
            await setReplyCount(id, message);
            await setCaption(id, message, message.content.caption.text);
            await addVideo(id, message, message.content.animation.animation, message.content.animation.thumbnail.file, false)
        }
        else if (contentType == "messageDocument")
        {
            if (!(id in loadedMessages)) // new message
                createMessage(id, chatId, chatTitle, message)
            await setReplyCount(id, message);
            await setCaption(id, message, message.content.caption.text);
            await addImage(id, message, message.content.document.thumbnail.file);
        }
        else if (contentType == "messageSticker")
        {
            if (!(id in loadedMessages)) // new message
                createMessage(id, chatId, chatTitle, message)
            await setReplyCount(id, message);
            await setCaption(id, message, "");
            var img = await addImage(id, message, message.content.sticker.thumbnail.file);

            // force stickers to be 256x256
            img.setAttribute("style", "width:256px")
        }
    }

    async function loadMessageFromChannel(chatId, chatTitle)
    {
        var startID = channels[chatId].latestMessage
        var messageCount = 1;

        var result = await client.send({
            '@type': 'getChatHistory',
            chat_id: chatId,
            from_message_id: startID, // start from the latest message
            offset: 0, // no offset needed
            limit: messageCount, // number of messages to fetch
        });

        result = await client.send({
            '@type': 'getChatHistory',
            chat_id: chatId,
            from_message_id: startID, // start from the latest message
            offset: 0, // no offset needed
            limit: messageCount, // number of messages to fetch
        });

        if (result['@type'] === 'messages')
        {
            // means we ran out of messages in the channel entirely?
            // and we should stop checking it for new messages.
            if (getSupportedMessageCount(result) == 0)
            {
                channels[chatId].exhausted = true;
                console.log(channels[chatId]);
                console.log("^ CHANNEL EXHAUSTED ^. WAS THIS CORRECT?");
                //if (channels[chatId].latestDOMmessage)
                //    channels[chatId].latestDOMmessage.hidden = false;
            }
            for (const message of result.messages)
            {
                console.log(message);
                addMessage(chatId, message, chatTitle);
            }
        }
    }

    function isMessageSupported(message)
    {
        var contentType = message.content["@type"];
        if (contentType == "messageText")
            return true;
        else if (contentType == "messagePhoto")
            return true;
        else if (contentType == "messageVideo")
            return true;
        else if (contentType == "messageAnimation")
            return true;
        else if (contentType == "messageDocument")
            return true;
        else if (contentType == "messageSticker")
            return true;
        return false;
    }
    function getSupportedMessageCount(result)
    {
        var count = 0
        for (const message of result.messages)
        {
            if (isMessageSupported(message))
                count++;
        }
        return count;
    }

    async function getChats()
    {
        const result = await client.send({
            '@type': 'getChats',
            chat_list: {
                '@type': 'chatListMain',
            },
            limit: 20,
        });

        return await client.send({
            '@type': 'getChats',
            chat_list: {
                '@type': 'chatListMain',
            },
            limit: 20,
        });
    }

    //function appendMessage(chatId, title, text)
    //{
    //    DOMmessage = document.createElement("message");
    //    if (channels[chatId].latestDOMmessage)
    //        channels[chatId].latestDOMmessage.hidden = false;
    //    DOMmessage.hidden = true;
    //    channels[chatId].latestDOMmessage = DOMmessage;
    //    var DOMmessage = DOMchannelList.appendChild(DOMmessage)
    //
    //    DOMmessage.textContent += title + ":\n" + text + "\n\n";
    //    return DOMmessage;
    //}

    var doneLoading = false;
    var sameCount = 0;
    var lastChannelCount;

    // check 10 times per second (every 100ms)
    var startupDelayChecker = setInterval(function ()
    {
        var channelCount = Object.keys(channels).length;
        if (channelCount == 0)
            return;

        if (lastChannelCount != channelCount)
        {
            lastChannelCount = channelCount;
            sameCount = 0;
        }
        else
        {
            sameCount++;
            // If we've held onto the same number of channels for 300ms, that means all the channels have probably been loaded and we can go ahead and start loading messages.
            if (sameCount >= 3)
            {
                console.log("DONE LOADING!");
                clearInterval(startupDelayChecker);
                doneLoading = true;
                Startup();
            }
        }
    }, 100);

    // Called once things are done loading.
    async function Startup()
    {
        DOMmainView.hidden = false;
        
        console.log(user);
    }

    async function update(data)
    {
        var type = data["@type"];
        DOMlogState.textContent = "state: " + type;

        if (type == "updateAuthorizationState")
        {
            var state = data.authorization_state["@type"];
            DOMlogStateAuth.textContent = "auth_state: " + state;

            if (state == "authorizationStateWaitTdlibParameters")
            {
                client.send({
                    '@type': 'setTdlibParameters',
                    parameters: {
                        '@type': 'tdlibParameters',
                        use_test_dc: false,
                        database_directory: 'tdlib',
                        files_directory: 'tdlib/files',
                        use_file_database: false,
                        use_chat_info_database: true,
                        use_message_database: true,
                        use_secret_chats: false,
                        api_id: 26827015,
                        api_hash: "66daa010ab01961d038809b996b791de",
                        system_language_code: 'en-GB',
                        device_model: 'Web',
                        system_version: 'Unknown',
                        application_version: '1.0',
                        enable_storage_optimizer: true,
                        ignore_file_names: false,
                    },
                });
            }
            else if (state == "authorizationStateWaitEncryptionKey")
            {
                client.send({
                    '@type': 'checkDatabaseEncryptionKey',
                    encryption_key: '', // no encryption
                });

                //client.send({'@type': 'checkDatabaseEncryptionKey', parameters:{client}});
                //await checkDatabaseEncryptionKey(client);
            }
            else if (state == "authorizationStateWaitPhoneNumber")
            {
                DOMphoneVerify.hidden = false;

                await waitListener(DOMphoneButton, "click");

                await client.send({
                    '@type': 'setAuthenticationPhoneNumber',
                    phone_number: DOMphoneNumber.value,
                    settings: {
                        '@type': 'phoneNumberAuthenticationSettings',
                        allow_flash_call: false,
                        is_current_phone_number: false,
                        allow_sms_retriever_api: false,
                    },
                });

                DOMphoneVerify.hidden = true;
            }
            else if (state == "authorizationStateWaitEmailAddress")
            {

            }
            else if (state == "authorizationStateWaitCode") // waiting for auth code
            {
                DOMcodeVerify.hidden = false;
                await waitListener(DOMcodeButton, "click");

                await client.send({
                    '@type': 'checkAuthenticationCode',
                    code: DOMcodeNumber.value,
                });
                DOMcodeVerify.hidden = true;
            }
            else if (state == "authorizationStateWaitRegistration")
            {

            }
            else if (state == "authorizationStateWaitPassword")
            {

            }
            else if (state == "authorizationStateReady")
            {
                getChats();

                // hoist
                user = await client.send({
                    "@type": "getMe",
                });
                DOMlogUserID.textContent = "user_id: " + user.id;
            }
        }

        else if (type == "updateNewChat")
        {
            if (data.chat.type["@type"] == "chatTypeSupergroup" && data.chat.type.is_channel)
            {
                //if (data.chat.title != "Torvid Content")
                //    return;

                if (data.chat.title.includes("Poss"))
                    return;

                const supergroup = await client.send({
                    '@type': 'getSupergroup',
                    supergroup_id: data.chat.type.supergroup_id,
                });

                // If you are a member
                if (supergroup.status["@type"] === 'chatMemberStatusMember' ||
                    supergroup.status["@type"] === 'chatMemberStatusCreator' ||
                    supergroup.status["@type"] === 'chatMemberStatusAdministrator' ||
                    supergroup.status["@type"] === 'chatMemberStatusRestricted')
                {
                    channels[data.chat.id] = {};
                    channels[data.chat.id].title = data.chat.title
                    channels[data.chat.id].loadedMessageCount = 0;
                    if (data.chat.photo)
                    {
                        var imagePath = await loadImage(data.chat.photo.small);
                        channels[data.chat.id].profilePicture = imagePath;
                    }
                    else
                    {
                        channels[data.chat.id].profilePicture = "missing-picture.png";
                    }

                    // load one thing form every channel
                    loadMessageFromChannel(data.chat.id, data.chat.title);
                }
                if (supergroup.status["@type"] === 'chatMemberStatusCreator')
                {
                    const chatInfo = await client.send({
                        "@type": "getSupergroupFullInfo",
                        supergroup_id: supergroup.id,
                    });

                    // the "timeline" channel description ends with your user ID, so it can be found here.
                    // mmmm yes sneaking in metadata my beloved.
                    if (chatInfo.description.endsWith(user.id))
                    {
                        timelineChannel = data.chat
                    }
                }
            }
        }
    }

    let options =
    {
        logVerbosityLevel: 1,
        jsLogVerbosityLevel: 3,
        mode: 'wasm',
        prefix: 'tdlib',
        readOnly: false,
        isBackground: false,
        useDatabase: true,
        wasmUrl: `3dee0f934ca1a5946a253599e3e442c6.wasm`,
        onUpdate: update
    };

    var client = new tdweb.default(options)
</script>