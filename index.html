<!DOCTYPE html>
<script>
    // Welcome to my single-file webapp, Telegram Timeline!
    // Written by Torivd and ChatGPT.
    // I'm not a web developer by trade. Hopefully I didn't fuck up any security stuff. :)

    // TODO: add tooltips to everything

</script>
<!--
teletime.net

    Now that twitter has no discoverability either, we could just move to telegram.
    I made this telegram client that looks like twitter. Displaying channels you are following in a unified feed.
    Tell me what you think, Poke @Torvid with thoughts and ideas. Especially if you are an experienced web developer <3.

Let's turn telegram into twitter
Want to escape twitter?
Already use telegram?

This web client takes all the telegram channels you follow and puts them into a single feed.

You can comment, like and retweet (forward) just like on twitter!

:)

[login thingy]

For the techy people,
This is app written in pure JS using TDweb, and is hosted statically on github.io here: [link]

I am not a web developer by trade, so this is all very new to me. Definitely tell me if I made some major security errors. I'm @torvid on telegram.


something something preocupied with whether they could

-->

<style>
    /*css to make it look like some terrible amalgum of telegram and twitter.*/

    body {
        background-color: #0E1621;
        color: #FFFFFF;
        font-family: 'Atkinson Hyperlegible', sans-serif; /*I like this font, open to changes though.*/
        font-style: normal;
    }

    /* needed for the hidden attribute to actually work lol */
    [hidden] {
        display: none !important;
    }

    message {
        background-color: #182533;
        display: block;
        margin: 1em;
        border-radius: 1em;
        /* width: 37em; */
        width: 37em;
        padding: 0.5em;
        height: 50%;
    }

    message-caption {
        display: block;
        padding: 0.5em;
        white-space: break-spaces;
    }

    message-title {
    }


    message message-profile img {
        width: 4em;
        height: 4em;
        border-radius: 4em;
    }

    /*title*/
    message message-profile span {
        position: relative;
        top: -3.0em;
        left: 0.5em;
        padding: 0.5em;
        color: #72BAFA;
        font-weight: Bold;
    }

    message-profile {
        display: block;
    }

    message-content {
        left: 4.5em;
        top: -3em;
        position: relative;
        max-width: 30em;
        display: block;
    }

    message-timestamp {
        text-align: right;
        display: block;
        padding: 0.5em;
        font-size: small;
        color: #71767B;
    }


    message-interactions {
        display: unset;
        height: 0em;
        margin: 2em;
        position: relative;
        top: 0em;
        left: -6em;
        white-space: nowrap;
        display: inline;
    }

    message-images {
        padding-right: 6em;
        display: grid;
        grid-template-columns: repeat(2, 1fr);
    }

        message-images img {
            margin: 0.1em;
            border-radius: 1em;
            width: 100%;
        }

        message-images video {
            border-radius: 1em;
            width: 100%;
        }

        message-images progress {
            width: 100%;
            display: block;
        }
        message-images img:nth-child(1) {
            grid-column: 1 / 3;
        }
        message-images video:nth-child(1) {
            grid-column: 1 / 3;
        }

    button {
        background-color: #182533;
        border: none;
        color: white;
        width: 7em;
        position: relative;
        display: inline;
    }

        button span {
            position: absolute;
            top: 0.7em;
            left: 6.5em;
        }
        /* after has background color that changes on hover */
        /* before has the icon. */
        button:hover::before {
            background-color: #40678b;
        }

        button::before {
            content: "";
            background-size: 2.5em 2.5em;
            background-repeat: no-repeat;
            background-position: center;
            width: 2.5em;
            height: 2.5em;
            position: absolute;
            transition: background-color 0.1s;
            border-radius: 2em;
        }

        button::after {
            content: "";
            background-image: url('icon-reply.png');
            background-size: 1.5em 1.5em;
            background-repeat: no-repeat;
            background-position: center;
            width: 2.5em;
            height: 2.5em;
            position: absolute;
        }

    .reply::after {
        background-image: url('icon-reply.png');
    }

    .retweet::after {
        background-image: url('icon-retweet.png');
    }

    .like::after {
        background-image: url('icon-like.png');
    }

    .views::after {
        background-image: url('icon-views.png');
    }

    .share::after {
        background-image: url('icon-share.png');
    }

</style>

<!-- TODO: Add meta tags and embed for marketing! -->
<head>
</head>

<body>
    <h1>Telegram Timeline</h1>

    <div style="white-space: break-spaces;">
        this is going to be crazy lol
        watch this space
        indev!
    </div>

    <div id="status" hidden>
        <p id="state">state: </p>
        <p id="auth_state">auth_state: </p>
    </div>


    <div id="phoneVerify">
        <label for="phone">Enter phone number:</label>
        <input type="tel" id="phoneNumber" name="phone">
        <input type="button" id="phoneButton" value="ok">
    </div>

    <div id="codeVerify">
        <label for="phone">Enter login code:</label>
        <input type="tel" id="codeNumber" name="phone">
        <input type="button" id="codeButton" value="ok">
        make sure you use the regional indicator (+46xxxx...)
    </div>

    <div id="mainView">
        <span>write a message!</span>
        <br />
        <input id="messageTextInput">
        <input type="button" id="messageSendButton" value="send">
        <!--<input type="button" value="getChats()" , onclick="getChats()">
        <input type="button" value="getMessages()" , onclick="getMessages()">-->
        <p id="channelList">

            <!--test message-->
            <!--<message>
            <message-retweeted-by>[person] "retweeted"</message-retweeted-by>
            <message-profile>
                <img src="Coal.png" />
                <span>Username</span>
            </message-profile>
            <message-content>
                <message-caption>
                    Lighting updates!

                    Moved from simple single-color light probes to "spherical harmonics". I don't fully understand the math. I barely understand the math at all but the results kind of speak for themselves. x>
                    This way of doing ambient light probes is the industry standard, used in both unreal and unity, so I'm still in good company.
                </message-caption>
                <message-images>
                    <video width="476" height="392" controls>
                        <source src="tank.mp4" type="video/mp4">
                    </video>
                    <progress id="progress" max="100" value="0">
                        Progress
                    </progress>
                </message-images>
                <message-interactions>
                    <button class="reply"><span>12</span></button>
                    <button class="retweet"><span>37</span></button>
                    <button class="like"><span>178</span></button>
                    <button class="views"><span>3,831</span></button>
                    <button class="share"><span></span></button>
                </message-interactions>
                <message-showthread>Show this thread</message-showthread>
            </message-content>
            <message-timestamp>test timestamp</message-timestamp>
            </message>-->
        </p>
        <!--<input type="button" value="loadMore()" , onclick="loadMore()">-->

    </div>
</body>

<!-- Telegram library-->
<script src="tdweb.js"></script>



<script>
    // from here - https://www.npmjs.com/package/last-seen-ago?activeTab=readme
    function getNiceTime(date)
    {
        var currentTime = Math.floor(Date.now() / 1000) // timestamp in seconds
        var differenceTime = currentTime - Math.floor(date / 1000);
        var seconds = differenceTime;
        var minutes = Math.floor(seconds / 60); // value 60 is seconds
        var hours = Math.floor(seconds / 3600); //value 3600 is 60 minutes * 60 sec
        var days = Math.floor(seconds / 86400); //86400 = 24 * 60 * 60;
        var weeks = Math.floor(seconds / 604800); // 7*24*60*60;
        var months = Math.floor(seconds / 2629440); //((365+365+365+365+366)/5/12)*24*60*60
        var years = Math.floor(seconds / 31553280); //(365+365+365+365+366)/5 * 24 * 60 * 60

        if (seconds <= 60)
        {
            return "Just Now";
        }
        else if (minutes <= 60)
        {
            if (minutes == 1) return "one minute ago";
            else return `${minutes} minutes ago`;
        }
        else if (hours <= 24)
        {
            if (hours == 1) return "an hour ago";
            else return `${hours} hrs ago`;
        }
        else if (days <= 7)
        {
            if (days == 1) return "yesterday";
            else return `${days} days ago`;
        }
        else if (weeks <= 4.3)
        {
            if (weeks == 1) return "a week ago";
            else return `${weeks} weeks ago`;
        }
        else if (months <= 12)
        {
            if (months == 1) return "a month ago";
            else return `${months} months ago`;
        }
        else
        {
            if (years == 1) return "one year ago";
            else return `${years} years ago`;
        }
    }

    // Creates a message and appends it to the DOM
    function createMessage(id, chatId, icon, username, text, message)
    {
        var replycount = 0;
        if (message.interaction_info.reply_info)
            replycount = message.interaction_info.reply_info.reply_count;

        var date = message.date;
        var forwardcount = message.interaction_info.forward_count;
        var viewcount = message.interaction_info.view_count;

        loadedMessages[id] = {};

        var DOMmessage = DOMchannelList.appendChild(document.createElement("message"));
        if (channels[chatId].latestDOMmessage)
            channels[chatId].latestDOMmessage.hidden = false;
        DOMmessage.hidden = true;
        channels[chatId].latestDOMmessage = DOMmessage;
        loadedMessages[id].DOMmessage = DOMmessage;

        loadedMessages[id].DOMprofile = loadedMessages[id].DOMmessage.appendChild(document.createElement("message-profile"));
        loadedMessages[id].DOMprofileImg = loadedMessages[id].DOMprofile.appendChild(document.createElement("img"));
        loadedMessages[id].DOMprofileUsername = loadedMessages[id].DOMprofile.appendChild(document.createElement("span"));

        loadedMessages[id].DOMcontent = loadedMessages[id].DOMmessage.appendChild(document.createElement("message-content"));
        loadedMessages[id].DOMcaption = loadedMessages[id].DOMcontent.appendChild(document.createElement("message-caption"));
        loadedMessages[id].DOMimages = loadedMessages[id].DOMcontent.appendChild(document.createElement("message-images"));
        loadedMessages[id].DOMinteractions = loadedMessages[id].DOMcontent.appendChild(document.createElement("message-interactions"));

        var DOMreply = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        DOMreply.setAttribute("class", "reply");
        DOMreply.appendChild(document.createElement("span")).textContent = replycount;//"10"

        var DOMretweet = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        DOMretweet.setAttribute("class", "retweet");
        DOMretweet.appendChild(document.createElement("span")).textContent = forwardcount;//"10"

        // TODO: add like support
        //var DOMlike = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        //DOMlike.setAttribute("class", "like");
        //DOMlike.appendChild(document.createElement("span")).textContent = "10"

        var DOMviews = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        DOMviews.setAttribute("class", "views");
        DOMviews.appendChild(document.createElement("span")).textContent = viewcount;//"10"

        var DOMshare = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        DOMshare.setAttribute("class", "share");
        DOMshare.appendChild(document.createElement("span")).textContent = ""

        loadedMessages[id].DOMtimestamp = DOMmessage.appendChild(document.createElement("message-timestamp"));

        loadedMessages[id].DOMprofileImg.src = channels[chatId].profilePicture;
        //if (image)
        //{
        //    loadedMessages[id].DOMimages.appendChild(image);
        //}
        loadedMessages[id].DOMprofileUsername.textContent = username
        loadedMessages[id].DOMcaption.textContent = text
        loadedMessages[id].DOMtimestamp.textContent = getNiceTime(new Date(date * 1000));//new Date(date * 1000).toLocaleString()
    }

    // get html elements
    DOMlogState = document.getElementById("state");
    DOMlogStateAuth = document.getElementById("auth_state");

    DOMphoneVerify = document.getElementById("phoneVerify");
    DOMphoneButton = document.getElementById("phoneButton");
    DOMphoneNumber = document.getElementById("phoneNumber");
    DOMphoneVerify.hidden = true;

    DOMcodeVerify = document.getElementById("codeVerify");
    DOMcodeButton = document.getElementById("codeButton");
    DOMcodeNumber = document.getElementById("codeNumber");
    DOMcodeVerify.hidden = true;

    DOMmainView = document.getElementById("mainView");
    DOMtestButton = document.getElementById("testButton");
    DOMchannelList = document.getElementById("channelList");
    DOMmainView.hidden = true;

    channelIDs = []


    // copied from stackoverflow, "wait for input"
    // https://stackoverflow.com/questions/51374649/using-async-functions-to-await-user-input-from-onclick
    function waitListener(element, listenerName)
    {
        return new Promise(function (resolve, reject)
        {
            var listener = event =>
            {
                element.removeEventListener(listenerName, listener);
                resolve(event);
            };
            element.addEventListener(listenerName, listener);
        });
    }

    loadedMessages = []
    channels = {}
    //window.onscroll = function ()
    //{
    //    if ((window.innerHeight + Math.ceil(window.pageYOffset)) >= document.body.offsetHeight)
    //    {
    //        alert('At the bottom!')
    //    }
    //}

    var scrollChecker = setInterval(function ()
    {
        scroll = document.body.offsetHeight - (window.innerHeight + Math.ceil(window.pageYOffset));
        if (scroll < 500)
        {
            loadMore();
        }
    }, 1000);

    async function loadMore()
    {
        if (!doneLoading)
            return;

        for (var j = 0; j < 10; j++)
        {
            var smallest = undefined;
            var smallestTimestamp = 0;
            var smallestID = 0;
            // find the channel with the most recent message and load that one
            for (var i = 0; i < Object.keys(channels).length; i++)
            {
                var channel = channels[Object.keys(channels)[i]];
                var timestamp = channel.latestMessageTimestamp
                if (timestamp > smallestTimestamp)
                {
                    smallestTimestamp = timestamp
                    smallest = channel;
                    smallestID = Object.keys(channels)[i];
                }
            }

            await loadMessageFromChannel(smallestID, smallest.title)
        }
    }

    async function loadImage(file)
    {
        return loadFile(file, "image/png", null);
    }
    //async function loadVideo(file)
    //{
    //    return loadFile(file, "video/mp4", null);
    //}
    async function loadFile(file, mime_type, setProgress)
    {
        var photo_id = file.id;
        // TODO: add support for streaming large video files.

        var imagePath;
        const CHUNK_SIZE = 1024 * 64; // 64KB

        let offset = 0;
        let fileSize = 0;

        const chunks = [];
        while (true)
        {
            var DLSize = CHUNK_SIZE
            if (fileSize == 0)
                DLSize = CHUNK_SIZE
            else
                DLSize = Math.min(CHUNK_SIZE, fileSize - offset)

            if (DLSize <= 0)
                break;

            var result = await client.send({
                '@type': 'downloadFile',
                file_id: file.id,
                priority: 1,
                offset: offset,
                limit: DLSize,
                synchronous: true, // download the file synchronously
            });

            fileSize = result.size;

            if (offset >= fileSize)
                break;

            //if (!result.local.path)
            //    return "";

            //console.log("photo_id: " + photo_id + ", " + result.id);

            const result2 = await client.send({
                '@type': 'readFilePart',
                file_id: result.id,
                offset: offset,
                count: Math.min(CHUNK_SIZE, fileSize - offset),
            });

            const fileData = result2.data;
            chunks.push(fileData);

            if (setProgress)
                setProgress(offset, fileSize);

            offset += CHUNK_SIZE;
        }
        const blob = new Blob(chunks, { type: mime_type });
        const blobUrl = URL.createObjectURL(blob);
        imagePath = blobUrl;

        if (setProgress)
            setProgress(fileSize, fileSize);

        return imagePath;
    }

    async function loadMessageFromChannel(chatId, chatTitle)
    {
        var startID = channels[chatId].latestMessage
        var messageCount = 1;

        var result = await client.send({
            '@type': 'getChatHistory',
            chat_id: chatId,
            from_message_id: startID, // start from the latest message
            offset: 0, // no offset needed
            limit: messageCount, // number of messages to fetch
        });

        result = await client.send({
            '@type': 'getChatHistory',
            chat_id: chatId,
            from_message_id: startID, // start from the latest message
            offset: 0, // no offset needed
            limit: messageCount, // number of messages to fetch
        });

        if (result['@type'] === 'messages')
        {
            for (const message of result.messages)
            {
                var id = message.media_album_id;
                if (message.media_album_id == 0)
                    id = message.id;

                channels[chatId].latestMessage = message.id;
                channels[chatId].loadedMessageCount++;
                channels[chatId].latestMessageTimestamp = message.date;

                var contentType = message.content["@type"];
                if (contentType == "messageText")
                {
                    createMessage(message.id, chatId, undefined, chatTitle, message.content.text.text, message);
                }
                else if (contentType == "messagePhoto")
                {
                    if (!(id in loadedMessages)) // new message
                        createMessage(id, chatId, undefined, chatTitle, message.content.caption.text, message)

                    // TODO: Lightbox

                    var img = loadedMessages[id].DOMimages.appendChild(document.createElement('img'));
                    img.src = await loadImage(message.content.photo.sizes[0].photo);

                    if (loadedMessages[id].DOMcaption.textContent == "")
                        loadedMessages[id].DOMcaption.textContent = message.content.caption.text;
                }
                else if (contentType == "messageVideo")
                {
                    if (!(id in loadedMessages)) // new message
                        createMessage(id, chatId, undefined, chatTitle, message.content.caption.text, message)

                    var thumbnailPath = await loadImage(message.content.video.thumbnail.file);


                    var video = loadedMessages[id].DOMimages.appendChild(document.createElement('video'));
                    video.setAttribute("controls", "");
                    video.setAttribute("poster", thumbnailPath);

                    var progress = loadedMessages[id].DOMimages.appendChild(document.createElement('progress'));

                    var videoUrl = await loadFile(message.content.video.video, "video/mp4", function (value, max)
                    {
                        if (value == max) // done
                        {
                            progress.hidden = true;
                        }
                        progress.setAttribute("value", value)
                        progress.setAttribute("max", max)
                    });

                    var source = document.createElement('source');
                    source.setAttribute("src", videoUrl);
                    video.appendChild(source);

                }
                else if (contentType == "messageAnimation")
                {
                    console.log(message)
                    if (!(id in loadedMessages)) // new message
                        createMessage(id, chatId, undefined, chatTitle, message.content.caption.text, message)

                    var thumbnailPath = await loadImage(message.content.animation.thumbnail.file);

                    var video = loadedMessages[id].DOMimages.appendChild(document.createElement('video'));
                    video.setAttribute("autoplay", "");
                    video.setAttribute("poster", thumbnailPath);

                    var progress = loadedMessages[id].DOMimages.appendChild(document.createElement('progress'));

                    var videoUrl = await loadFile(message.content.animation.animation, "video/mp4", function (value, max)
                    {
                        if (value == max) // done
                        {
                            progress.hidden = true;
                        }
                        progress.setAttribute("value", value)
                        progress.setAttribute("max", max)
                    });

                    var source = document.createElement('source');
                    source.setAttribute("src", videoUrl);
                    video.appendChild(source);
                    //appendMessage(chatId, chatTitle, "[animation]\n" + message.content.caption.text)
                }
                else if (contentType == "messageDocument")
                {
                    if (!(id in loadedMessages)) // new message
                        createMessage(id, chatId, undefined, chatTitle, message.content.caption.text, message)

                    // TODO: download button for the full document

                    var img = loadedMessages[id].DOMimages.appendChild(document.createElement('img'));
                    img.src = await loadImage(message.content.document.thumbnail.file);

                    if (loadedMessages[id].DOMcaption.textContent == "")
                        loadedMessages[id].DOMcaption.textContent = message.content.caption.text;
                    if (img)
                        loadedMessages[id].DOMimages.appendChild(img);
                }
                else if (contentType == "messageChatChangeTitle")
                {

                }
                else if (contentType == "messageSupergroupChatCreate")
                {

                }
                else if (contentType == "messageChatChangePhoto")
                {

                }
                else if (contentType == "messageSticker")
                {
                    if (!(id in loadedMessages)) // new message
                        createMessage(id, chatId, undefined, chatTitle, "", message)

                    var img = loadedMessages[id].DOMimages.appendChild(document.createElement('img'));
                    img.src = await loadImage(message.content.sticker.thumbnail.file);
                }
                else
                {
                    appendMessage(chatId, chatTitle, "This message type (" + message.content["@type"] + ") is not yet suported, go harass @Torvid about it.");
                }
            }
        }
    }

    async function getChats()
    {
        const result = await client.send({
            '@type': 'getChats',
            chat_list: {
                '@type': 'chatListMain',
            },
            limit: 20,
        });

        return await client.send({
            '@type': 'getChats',
            chat_list: {
                '@type': 'chatListMain',
            },
            limit: 20,
        });
    }

    function appendMessage(chatId, title, text)
    {
        DOMmessage = document.createElement("message");
        if (channels[chatId].latestDOMmessage)
            channels[chatId].latestDOMmessage.hidden = false;
        DOMmessage.hidden = true;
        channels[chatId].latestDOMmessage = DOMmessage;
        var DOMmessage = DOMchannelList.appendChild(DOMmessage)

        DOMmessage.textContent += title + ":\n" + text + "\n\n";
        return DOMmessage;
    }

    doneLoading = false;
    var sameCount = 0;
    var lastChannelCount;

    // check 10 times per second (every 100ms)
    var startupDelayChecker = setInterval(function ()
    {
        var channelCount = Object.keys(channels).length;
        if (channelCount == 0)
            return;

        if (lastChannelCount != channelCount)
        {
            lastChannelCount = channelCount;
            sameCount = 0;
        }
        else
        {
            sameCount++;
            // If we've held onto the same number of channels for 300ms, that means all the channels have probably been loaded and we can go ahead and start loading messages.
            if (sameCount >= 3)
            {
                console.log("DONE LOADING!");
                clearInterval(startupDelayChecker);
                doneLoading = true;
            }
        }


    }, 100);

    async function update(data)
    {
        var type = data["@type"];
        DOMlogState.textContent = "state: " + type;

        if (type == "updateAuthorizationState")
        {
            var state = data.authorization_state["@type"];
            DOMlogStateAuth.textContent = "auth_state: " + state;

            if (state == "authorizationStateWaitTdlibParameters")
            {
                client.send({
                    '@type': 'setTdlibParameters',
                    parameters: {
                        '@type': 'tdlibParameters',
                        use_test_dc: false,
                        database_directory: 'tdlib',
                        files_directory: 'tdlib/files',
                        use_file_database: false,
                        use_chat_info_database: true,
                        use_message_database: true,
                        use_secret_chats: false,
                        api_id: 26827015,
                        api_hash: "66daa010ab01961d038809b996b791de",
                        system_language_code: 'en-GB',
                        device_model: 'Web',
                        system_version: 'Unknown',
                        application_version: '1.0',
                        enable_storage_optimizer: true,
                        ignore_file_names: false,
                    },
                });
            }
            else if (state == "authorizationStateWaitEncryptionKey")
            {
                client.send({
                    '@type': 'checkDatabaseEncryptionKey',
                    encryption_key: '', // no encryption
                });

                //client.send({'@type': 'checkDatabaseEncryptionKey', parameters:{client}});
                //await checkDatabaseEncryptionKey(client);
            }
            else if (state == "authorizationStateWaitPhoneNumber")
            {
                DOMphoneVerify.hidden = false;

                await waitListener(DOMphoneButton, "click");

                await client.send({
                    '@type': 'setAuthenticationPhoneNumber',
                    phone_number: DOMphoneNumber.value,
                    settings: {
                        '@type': 'phoneNumberAuthenticationSettings',
                        allow_flash_call: false,
                        is_current_phone_number: false,
                        allow_sms_retriever_api: false,
                    },
                });

                DOMphoneVerify.hidden = true;
            }
            else if (state == "authorizationStateWaitEmailAddress")
            {

            }
            else if (state == "authorizationStateWaitCode") // waiting for auth code
            {
                DOMcodeVerify.hidden = false;
                await waitListener(DOMcodeButton, "click");

                await client.send({
                    '@type': 'checkAuthenticationCode',
                    code: DOMcodeNumber.value,
                });
                DOMcodeVerify.hidden = true;
            }
            else if (state == "authorizationStateWaitRegistration")
            {

            }
            else if (state == "authorizationStateWaitPassword")
            {

            }
            else if (state == "authorizationStateReady")
            {
                DOMmainView.hidden = false;

                getChats();
            }
        }

        else if (type == "updateNewChat")
        {
            if (data.chat.type["@type"] == "chatTypeSupergroup" && data.chat.type.is_channel)
            {
                if (data.chat.title != "Torvid Content")
                    return;
                const supergroup = await client.send({
                    '@type': 'getSupergroup',
                    supergroup_id: data.chat.type.supergroup_id,
                });

                // If you are a member
                if (supergroup.status["@type"] === 'chatMemberStatusMember' ||
                    supergroup.status["@type"] === 'chatMemberStatusCreator' ||
                    supergroup.status["@type"] === 'chatMemberStatusAdministrator' ||
                    supergroup.status["@type"] === 'chatMemberStatusRestricted')
                {

                    channels[data.chat.id] = {};
                    channels[data.chat.id].title = data.chat.title
                    channels[data.chat.id].loadedMessageCount = 0;
                    if (data.chat.photo)
                    {
                        var imagePath = await loadImage(data.chat.photo.small);
                        channels[data.chat.id].profilePicture = imagePath;
                    }
                    else
                    {
                        channels[data.chat.id].profilePicture = "missing-picture.png";
                    }

                    // load one thing form every channel
                    loadMessageFromChannel(data.chat.id, data.chat.title);
                }
            }
        }
    }

    let options =
    {
        logVerbosityLevel: 1,
        jsLogVerbosityLevel: 3,
        mode: 'wasm', // 'wasm-streaming'/'wasm'/'asmjs'
        prefix: 'tdlib',
        readOnly: false,
        isBackground: false,
        useDatabase: true,
        wasmUrl: `3dee0f934ca1a5946a253599e3e442c6.wasm`,
        onUpdate: update
    };

    // hoist
    client = new tdweb.default(options)
</script>