<!DOCTYPE html>
<script>
    // Welcome to my single-file webapp, Telegram Timeline!
    // Written by Torivd and ChatGPT.
    // I'm not a web developer by trade. Hopefully I didn't fuck up any security stuff. :)

    // TODO:
    // Add tooltips to everything
    // Add suppor tfor Posting messages to a custom channel
    // viewing a single channel
        // Loading channel description, etc
    // "share" button that works
    // Add meta-tags with some nice marketing images

    // Lightbox forimages
    // Arbitrary file download?
    // Download button for files

    // TODO: add DMs in the bottom right

    // TODO: add a list of everyone you currently follow
    //  Maybe have it ask your interests? (memes, furry, cars, food/cooking, etc)

    // TODO: make it so posts are cleverly filtered such that channels that spam a lot show up less

    // TODO: add support for looking at a single message

    // TODO: make the UI niced, show description, etc

    // TODO: add support for commenting inline, comment threading

</script>
<!--
teletime.net

    Now that twitter has no discoverability anymore, we could just move to telegram. :)
    This telegram client takes all the channels you follow and puts them into a single feed.
    Tell me what you think, Poke @Torvid with thoughts and ideas. Especially if you are an experienced web developer <3.

    The whole website is a single ~2kLOC html file containing all the html/css/script, so it should be easy for anyone to audit.
    Only external library is TDweb, a wrapper for the telegram API found here:
    https://www.npmjs.com/package/tdweb

    LIVE version is here: https://teletime.net/
    DEV version is here: http://212.100.102.124:8000/

Let's turn telegram into twitter
Want to escape twitter?
Already use telegram?

This web client takes all the telegram channels you follow and puts them into a single feed.

You can comment, like and retweet (forward) just like on twitter!

:)

[login thingy]

For the techy people,
This is app written in pure JS using TDweb, and is hosted statically on github.io here: [link]

something something preocupied with whether they could

-->

<style>
    /*css to make it look like some terrible amalgum of telegram and twitter.*/
    :root {
        --background: #0E1621;
        --message: #182533;
        --message-hover: #23364a;
        --button-hover: #40678b;
        --user-text: #ffffff;
    }


    body {
        background-color: var(--background);
        color: #FFFFFF;
        font-family: 'Atkinson Hyperlegible', sans-serif; /*I like this font, open to changes though.*/
        font-style: normal;
    }

    /* needed for the hidden attribute to actually work lol */
    [hidden] {
        display: none !important;
    }

    message {
        background-color: var(--message);
        display: block;
        margin: 1em;
        border-radius: 1em;
        width: 37em;
        padding: 0.5em;
        height: 50%;
        transition: background-color 0.1s;
    }

    message-caption {
        display: block;
        padding: 0.5em;
        white-space: break-spaces;
    }

    message-title {
    }

    message:hover {
        background-color: var(--message-hover);
        cursor: pointer;
    }
    message message-profile img {
        width: 4em;
        height: 4em;
        border-radius: 4em;
    }

    message message-profile span {
        position: relative;
        top: -3.0em;
        left: 0.5em;
        padding: 0.5em;
        color: #72BAFA;
        font-weight: Bold;
    }

    message-profile {
        display: block;
        width: fit-content;
    }

    message-content {
        left: 4.5em;
        top: -3em;
        position: relative;
        max-width: 30em;
        width: fit-content;
        display: block;
    }

    message-timestamp {
        text-align: right;
        display: block;
        padding: 0.5em;
        font-size: small;
        color: #71767B;
    }

    message-interactions {
        /* margin: 2em; */
        position: relative;
        top: -2em;
        left: 1em;
        white-space: nowrap;
        display: block;
    }

    message-images {
        margin-right: 6em;
        display: grid;
        grid-template-columns: repeat(2, 1fr);
    }

        message-images img {
            margin: 0.1em;
            border-radius: 1em;
            width: 100%;
        }

        message-images video {
            border-radius: 1em;
            width: 100%;
        }

        message-images progress {
            width: 100%;
            display: block;
        }

        message-images img:nth-child(1) {
            grid-column: 1 / 3;
        }

        message-images video:nth-child(1) {
            grid-column: 1 / 3;
        }

    button {
        background-color: #FFFFFF00;
        border: none;
        color: white;
        width: 7.5em;
        /* height: 0em; */
        position: relative;
        display: inline;
        cursor: pointer;
    }

        button span {
            position: absolute;
            top: 0.8em;
            left: 6.5em;
        }

        button:hover::before {
            background-color: var(--button-hover);
        }

        .hovercircle::before {
            content: "";
            background-size: 2.5em 2.5em;
            background-repeat: no-repeat;
            background-position: center;
            width: 2.5em;
            height: 2.5em;
            position: absolute;
            transition: background-color 0.1s;
            border-radius: 2em;
        }

        button::after {
            content: "";
            background-image: url('icon-reply.png');
            background-size: 1.2em 1.2em;
            background-repeat: no-repeat;
            background-position: center;
            width: 2.5em;
            height: 2.5em;
            position: absolute;
        }

    .reply::after {
        background-image: url('icon-reply.png');
    }

    .retweet::after {
        background-image: url('icon-retweet.png');
    }

    .like::after {
        background-image: url('icon-like.png');
    }

    .views::after {
        background-image: url('icon-views.png');
    }

    .share::after {
        background-image: url('icon-share.png');
    }

    .disabled {
        filter: sepia(100%) saturate(0%) brightness(50%);
    }

    .messageInput {
        display: flex;
        flex-direction: row;
        align-items: flex-start; /* Aligns the items vertically */
        gap: 10px; /* Optional: Adds space between the textarea and the button */
    }
    #messageTextbox {
        width: 38em;
        min-height: 4em; /* Adjust the height as needed */
        resize: vertical; /* Allows vertical resizing of the textarea */
    }
    #messageSendButton {
        width:5em;
        height: 4em;
    }


    /*taken from w3schools*/
    .loader {
        border: 8px solid #182533;
        border-radius: 50%;
        border-top: 8px solid #3498db;
        width: 3em;
        height: 3em;
        /* -webkit-animation: spin 2s linear infinite; */ /* Safari */
        animation: spin 2s linear infinite;
    }
    /* Safari */
    @-webkit-keyframes spin {
        0% {
            -webkit-transform: rotate(0deg);
        }
        100% {
            -webkit-transform: rotate(360deg);
        }
    }
    @keyframes spin {
        0% {
            transform: rotate(0deg);
        }
        100% {
            transform: rotate(360deg);
        }
    }

</style>

<head>
</head>

<body>
    <h1>Telegram Timeline</h1>

    <div style="white-space: break-spaces;">
        this is going to be crazy
        in development!
    </div>

    <div id="status">
        <p id="state">state: </p>
        <p id="auth_state">auth_state: </p>
        <p id="user_id">user_id: </p>
    </div>


    <div id="phoneVerify">
        <label for="phone">Enter phone number:</label>
        <input type="tel" id="phoneNumber" name="phone">
        <input type="button" id="phoneButton" value="ok">
        <div id="phoneVerifyError"></div>
        <br />
        You need to use the regional indicator (+46xxxx...)
    </div>

    <div id="codeVerify">
        <label for="phone">Login code sent to your telegram account! Enter it here:</label><br />
        <input type="tel" id="codeNumber" name="phone">
        <input type="button" id="codeButton" value="ok">
        <div id="codeVerifyError"></div>
    </div>

    <div id="mainView">
        <span>write a message!</span>
        <br />

        <div class="messageInput">
            <textarea id="messageTextbox"></textarea>
            <input type="button" id="messageSendButton" value="send">
        </div>

        <p id="channelList">
        </p>
    </div>

    <center>
        <div id="loader" class="loader"></div>
    </center>
</body>

<!-- Telegram library-->
<script src="tdweb.js"></script>

<script>
    'use strict'; // first we use strict, because hoisting is unbased

    // then some utility functions
    // from here - https://www.npmjs.com/package/last-seen-ago?activeTab=readme
    function getNiceTime(date)
    {
        var currentTime = Math.floor(Date.now() / 1000) // timestamp in seconds
        var differenceTime = currentTime - Math.floor(date / 1000);
        var seconds = differenceTime;
        var minutes = Math.floor(seconds / 60);
        var hours = Math.floor(seconds / 3600);
        var days = Math.floor(seconds / 86400);
        var weeks = Math.floor(seconds / 604800);
        var months = Math.floor(seconds / 2629440);
        var years = Math.floor(seconds / 31553280);

        if (seconds <= 60)
        {
            return "Just Now";
        }
        else if (minutes <= 60)
        {
            if (minutes == 1) return "one minute ago";
            else return `${minutes} minutes ago`;
        }
        else if (hours <= 24)
        {
            if (hours == 1) return "an hour ago";
            else return `${hours} hrs ago`;
        }
        else if (days <= 7)
        {
            if (days == 1) return "yesterday";
            else return `${days} days ago`;
        }
        else if (weeks <= 4.3)
        {
            if (weeks == 1) return "a week ago";
            else return `${weeks} weeks ago`;
        }
        else if (months <= 12)
        {
            if (months == 1) return "a month ago";
            else return `${months} months ago`;
        }
        else
        {
            if (years == 1) return "one year ago";
            else return `${years} years ago`;
        }
    }

    // copied from stackoverflow, "wait for input"
    // https://stackoverflow.com/questions/51374649/using-async-functions-to-await-user-input-from-onclick
    function waitListener(element, listenerName)
    {
        return new Promise(function (resolve, reject)
        {
            var listener = event =>
            {
                element.removeEventListener(listenerName, listener);
                resolve(event);
            };
            element.addEventListener(listenerName, listener);
        });
    }

    // some global variables :)
    var loadedMessages = [] // groups messages into albums
    var allMessages = [] // does not group messages into albums
    var channels = {}
    var user = undefined; // current user
    var timelineChannel = undefined // your timeline channel
    var bSingleChannel = false;
    var bSingleMessage = false;
    var bSingleChannelFound = false;
    const urlParams = new URLSearchParams(window.location.search);
    var channel_name_or_id = urlParams.get("channel");
    var channel_message_id = urlParams.get("message");

    // nukes all loaded messages
    async function reset()
    {
        //window.location.href = "?&channel=magpistreams";
        //window.location.href = "?&private_channel_id=343245532";
    }


    // get html elements
    var DOMlogState = document.getElementById("state");
    var DOMlogStateAuth = document.getElementById("auth_state");
    var DOMlogUserID = document.getElementById("user_id");

    var DOMphoneVerify = document.getElementById("phoneVerify");
    var DOMphoneVerifyError = document.getElementById("phoneVerifyError");
    var DOMphoneButton = document.getElementById("phoneButton");
    var DOMphoneNumber = document.getElementById("phoneNumber");
    DOMphoneVerify.hidden = true;

    var DOMcodeVerify = document.getElementById("codeVerify");
    var DOMcodeVerifyError = document.getElementById("codeVerifyError");
    var DOMcodeButton = document.getElementById("codeButton");
    var DOMcodeNumber = document.getElementById("codeNumber");
    DOMcodeVerify.hidden = true;

    var DOMmainView = document.getElementById("mainView");
    var DOMtestButton = document.getElementById("testButton");
    var DOMchannelList = document.getElementById("channelList");
    var DOMmessageSendButton = document.getElementById("messageSendButton");
    var DOMmessageTextbox = document.getElementById("messageTextbox");

    var DOMloader = document.getElementById("loader");

    DOMmainView.hidden = true;

    DOMmessageSendButton.addEventListener("click", function ()
    {
        sendMessage();
    });

    DOMmessageTextbox.addEventListener("keydown", function (event)
    {
        if (event.shiftKey)
            return;
        if (event.ctrlKey)
            return;
        if (event.key === "Enter")
        {
            event.preventDefault();

            sendMessage();
        }
    });

    var scrollChecker = setInterval(function ()
    {
        scroll = document.body.offsetHeight - (window.innerHeight + Math.ceil(window.pageYOffset));
        if (scroll < 500)
        {
            loadMore();
        }
    }, 250);

    async function sendMessage()
    {
        if (DOMmessageTextbox.value == "")
            return;

        // Send a text message to the channel
        const result = await client.send({
            "@type": "sendMessage",
            chat_id: timelineChannel.id,
            input_message_content: {
                "@type": "inputMessageText",
                text: {
                    "@type": "formattedText",
                    text: DOMmessageTextbox.value,
                },
                disable_web_page_preview: false,
                clear_draft: true,
            },
        });

        DOMmessageTextbox.value = "";
        addMessage(result, timelineChannel);
    }

    // Creates a message and appends it to the DOM
    async function createMessage(id, chat, message)
    {
        var date = message.date;
        var forwardcount = message.interaction_info.forward_count;
        var viewcount = message.interaction_info.view_count;

        var bCommentsEnabled = channels[chat.id].supergroup.has_linked_chat;

        var retweet_message = undefined
        var title = undefined;
        var profile_pic = undefined;
        var username = undefined;
        if (message.forward_info) // if it was forwarded
        {
            // forwarded from a user
            if (message.forward_info.origin["@type"] == "messageForwardOriginUser")
            {
                var user = await client.send({
                    "@type": "getUser",
                    "user_id": message.forward_info.origin.sender_user_id,
                });
                username = user.username;
                profile_pic = await loadImage(user.profile_photo.small);
            }
            else if (message.forward_info.origin["@type"] == "messageForwardOriginChannel")
            {
                var channel = channels[message.forward_info.origin.chat_id];
                if (channel)
                {
                    profile_pic = await loadImage(channel.chat.photo.small);
                    title = channel.chat.title
                    username = channel.supergroup.username
                    if (!username)
                        username = channel.chat.id
                }
            }

            retweet_message = chat.title;
        }
        else
        {
            if (channels[chat.id].chat.photo)
            {
                profile_pic = await loadImage(channels[chat.id].chat.photo.small);
                //profile_pic = "data:image/jpeg;base64," + channels[chat.id].chat.photo.minithumbnail.data;
            }
            else
            {
                profile_pic = "missing-picture.png"
            }

            title = chat.title;
            username = channels[chat.id].supergroup.username
            if (!username)
                username = chat.id
        }

        loadedMessages[id] = {};
        if (loadedMessages[id].messages == undefined)
            loadedMessages[id].messages = []
        loadedMessages[id].messages.push(message);

        var firstChildThatIsOlderThanNewMessage = undefined
        for (const child of DOMchannelList.children)
        {
            if (date > child.getAttribute("timestamp"))
            {
                firstChildThatIsOlderThanNewMessage = child
                break;
            }
        }
        
        var DOMmessage = document.createElement("message");


        if (firstChildThatIsOlderThanNewMessage)
        {
            DOMchannelList.insertBefore(DOMmessage, firstChildThatIsOlderThanNewMessage);
        }
        else
        {
            DOMchannelList.appendChild(DOMmessage);
        }

        if (channels[chat.id].latestDOMmessage)
        {
            DOMloader.hidden = true;
            channels[chat.id].latestDOMmessage.hidden = false;
        }

        DOMmessage.hidden = true;

        channels[chat.id].latestDOMmessage = DOMmessage;
        loadedMessages[id].DOMmessage = DOMmessage;

        DOMmessage.setAttribute("timestamp", date)
        if (retweet_message)
        {
            loadedMessages[id].DOMretweeted_by = loadedMessages[id].DOMmessage.appendChild(document.createElement("message-retweet"));
            loadedMessages[id].DOMmessage.textContent = chat.title + " retweeted"
        }

        var DOMprofile              = DOMmessage.appendChild(document.createElement("message-profile"));
        var DOMprofileImg           = DOMprofile.appendChild(document.createElement("img"));
        var DOMprofileUsername      = DOMprofile.appendChild(document.createElement("span"));
        loadedMessages[id].DOMprofile           = DOMprofile;
        loadedMessages[id].DOMprofileImg        = DOMprofileImg;
        loadedMessages[id].DOMprofileUsername   = DOMprofileUsername;

        var DOMcontent       = DOMmessage.appendChild(document.createElement("message-content"));
        var DOMcaption       = DOMcontent.appendChild(document.createElement("message-caption"));
        var DOMimages        = DOMcontent.appendChild(document.createElement("message-images"));
        var DOMinteractions  = DOMmessage.appendChild(document.createElement("message-interactions"));
        loadedMessages[id].DOMcontent       = DOMcontent;
        loadedMessages[id].DOMcaption       = DOMcaption;
        loadedMessages[id].DOMimages        = DOMimages;
        loadedMessages[id].DOMinteractions  = DOMinteractions;

        DOMmessage.addEventListener("click", async function (event)
        {
            var bHitMessage = false;
            var bHitProfile = false;
            if (event.target == DOMmessage)
                bHitMessage = true;
            if (event.target == DOMcontent)
                bHitMessage = true;
            if (event.target == DOMimages)
                bHitMessage = true;
            if (event.target == DOMprofile)
                bHitMessage = true;

            if (event.target == DOMprofileImg)
                bHitProfile = true;
            if (event.target == DOMprofileUsername)
                bHitProfile = true;

            if (bHitMessage) // go to message / comments
            {
                window.location.href = "?channel=" + username + "&message=" + chat.id;
            }
            else if (bHitProfile) // go to profile
            {
                window.location.href = "?channel="+username;
            }
        });

        loadedMessages[id].DOMreply = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        if (bCommentsEnabled)
            loadedMessages[id].DOMreply.setAttribute("class", "reply hovercircle");
        else
            loadedMessages[id].DOMreply.setAttribute("class", "reply disabled");
        loadedMessages[id].DOMreplyText = loadedMessages[id].DOMreply.appendChild(document.createElement("span"))
        loadedMessages[id].DOMreplyText.textContent = 0;

        loadedMessages[id].DOMretweet = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        loadedMessages[id].DOMretweet.setAttribute("class", "retweet hovercircle");
        loadedMessages[id].DOMretweet.appendChild(document.createElement("span")).textContent = forwardcount;

        loadedMessages[id].DOMretweet.addEventListener("click", function (inner_id, inner_chatId)
        {
            return async function ()
            {
                var fwd = loadedMessages[inner_id].messages;
                var msgs = [];
                for (var i = 0; i < fwd.length; i++)
                {
                    msgs.push(fwd[i].id)
                }
                client.send({
                    '@type': 'forwardMessages',
                    from_chat_id: inner_chatId,
                    chat_id: timelineChannel.id,
                    message_ids: msgs,
                });
            }
        }(id, chat.id));
        

        loadedMessages[id].DOMlike = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        loadedMessages[id].DOMlike.setAttribute("class", "like hovercircle");
        loadedMessages[id].DOMlike.appendChild(document.createElement("span")).textContent = 0;

        var DOMviews = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        DOMviews.setAttribute("class", "views hovercircle");
        DOMviews.appendChild(document.createElement("span")).textContent = viewcount;

        var DOMshare = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        DOMshare.setAttribute("class", "share hovercircle");
        DOMshare.appendChild(document.createElement("span")).textContent = ""

        loadedMessages[id].DOMtimestamp = DOMmessage.appendChild(document.createElement("message-timestamp"));

        loadedMessages[id].DOMprofileImg.src = profile_pic;
        loadedMessages[id].DOMprofileUsername.textContent = title
        loadedMessages[id].DOMtimestamp.textContent = getNiceTime(new Date(date * 1000));
    }

    async function loadMore()
    {
        if (!doneLoading)
            return;

        //for (var j = 0; j < 5; j++)
        {
            var smallest = undefined;
            var smallestTimestamp = 0;
            var smallestID = 0;
            // find the channel with the most recent message and load that one
            for (var i = 0; i < Object.keys(channels).length; i++)
            {
                var channel = channels[Object.keys(channels)[i]];
                if (channel.exhausted)
                    continue;

                var timestamp = channel.latestMessageTimestamp
                if (timestamp > smallestTimestamp)
                {
                    smallestTimestamp = timestamp
                    smallest = channel;
                    smallestID = Object.keys(channels)[i];
                }
            }
            if (smallest)
                loadMessageFromChannel(smallest.chat)
        }
    }

    var imageCache = {};

    async function loadImage(file)
    {
        //return loadFile(file, "image/png", null);
        if (!imageCache.hasOwnProperty(file.id))
        {
            imageCache[file.id] = loadFile(file, "image/png", null);
        }
        return imageCache[file.id];
    }
    async function loadFileBlob(file, mime_type, setProgress)
    {
        // TODO: add support for streaming large video files.

        const CHUNK_SIZE = 1024 * 64; // 64KB

        let offset = 0;
        let fileSize = file.size;

        const chunks = [];
        while (true)
        {
            var DLSize = Math.min(CHUNK_SIZE, fileSize - offset)

            if (fileSize == 0) // unknown filesize, just start downloading it
                DLSize = CHUNK_SIZE;

            if (DLSize <= 0)
                break;

            if (!file.is_downloading_completed)
            {
                var result = await client.send({
                    '@type': 'downloadFile',
                    file_id: file.id,
                    priority: 1,
                    offset: offset, // where in the file to start downloading
                    limit: DLSize, // how much to download in bytes
                    synchronous: true, // download the file synchronously
                });
                fileSize = result.size;
            }

            const result2 = await client.send({
                '@type': 'readFilePart',
                file_id: file.id,
                offset: offset,
                count: Math.min(CHUNK_SIZE, fileSize - offset),
            });

            const fileData = result2.data;
            chunks.push(fileData);

            if (setProgress)
                setProgress(offset, fileSize);

            offset += CHUNK_SIZE;
        }
        const blob = new Blob(chunks, { type: mime_type });
        if (setProgress)
            setProgress(fileSize, fileSize);

        return blob;
    }
    async function loadFile(file, mime_type, setProgress)
    {
        const blob = await loadFileBlob(file, mime_type, setProgress)
        return URL.createObjectURL(blob);
    }
    async function setReplyCount(id, message)
    {
        if (loadedMessages[id].DOMreplyText.textContent == 0 && message.interaction_info.reply_info)
            loadedMessages[id].DOMreplyText.textContent = message.interaction_info.reply_info.reply_count;
    }
    async function addImage(id, message, image)
    {
        var images = loadedMessages[id].DOMimages;

        var img = document.createElement('img');

        images.insertBefore(img, images.firstChild);

        loadImage(image).then((src) =>
        {
            img.src = src;
        })
        return img;
    }
    async function addVideo(id, message, video, thumbnail, controls)
    {
        var thumbnailPath = await loadImage(thumbnail);
        var DOMvideo = document.createElement('video');
        var images = loadedMessages[id].DOMimages;
        images.insertBefore(DOMvideo, images.firstChild);

        if (controls)
        {
            DOMvideo.setAttribute("controls", "");
        }
        else
        {
            DOMvideo.setAttribute("autoplay", "");
            DOMvideo.setAttribute("loop", "");
        }

        DOMvideo.setAttribute("poster", thumbnailPath);

        var progress = images.appendChild(document.createElement('progress'));
        var videoUrl = await loadFile(video, "video/mp4", function (value, max)
        {
            if (value == max) // done
            {
                progress.hidden = true;
            }
            progress.setAttribute("value", value)
            progress.setAttribute("max", max)
        });

        var source = document.createElement('source');
        source.setAttribute("src", videoUrl);
        DOMvideo.appendChild(source);
    }
    async function setCaption(id, message, caption)
    {
        if (loadedMessages[id].DOMcaption.textContent == "")
            loadedMessages[id].DOMcaption.textContent = caption;
    }
    function isMessageSupported(message)
    {
        if (message.id in allMessages) // we got the same message twice. reject it!
            return false;

        var contentType = message.content["@type"];
        if (contentType == "messageText")
            return true;
        else if (contentType == "messagePhoto")
            return true;
        else if (contentType == "messageVideo")
            return true;
        else if (contentType == "messageAnimation")
            return true;
        else if (contentType == "messageDocument")
            return true;
        else if (contentType == "messageSticker")
            return true;
        return false;
    }
    function getSupportedMessageCount(result)
    {
        var count = 0
        for (const message of result.messages)
        {
            if (isMessageSupported(message))
                count++;
        }
        return count;
    }


    // high level function to download and add a message to the timeline.
    async function addMessage(message, chat)
    {

        allMessages[message.id] = {};

        var id = message.media_album_id;
        if (message.media_album_id == 0)
            id = message.id;

        channels[chat.id].latestMessage = message.id;
        channels[chat.id].latestMessageTimestamp = message.date;

        var contentType = message.content["@type"];
        if (contentType == "messageText")
        {
            if (!(id in loadedMessages)) // new message
                await createMessage(id, chat, message);
            await setReplyCount(id, message);
            await setCaption(id, message, message.content.text.text);
        }
        else if (contentType == "messagePhoto")
        {
            if (!(id in loadedMessages)) // new message
                await createMessage(id, chat, message)
            await setReplyCount(id, message);
            await setCaption(id, message, message.content.caption.text);
            await addImage(id, message, message.content.photo.sizes[0].photo);
        }
        else if (contentType == "messageVideo")
        {
            if (!(id in loadedMessages)) // new message
                await createMessage(id, chat, message)
            await setReplyCount(id, message);
            await setCaption(id, message, message.content.caption.text);
            await addVideo(id, message, message.content.video.video, message.content.video.thumbnail.file, true)
        }
        else if (contentType == "messageAnimation")
        {
            if (!(id in loadedMessages)) // new message
                await createMessage(id, chat, message)
            await setReplyCount(id, message);
            await setCaption(id, message, message.content.caption.text);
            await addVideo(id, message, message.content.animation.animation, message.content.animation.thumbnail.file, false)
        }
        else if (contentType == "messageDocument")
        {
            if (!(id in loadedMessages)) // new message
                await createMessage(id, chat, message)
            await setReplyCount(id, message);
            await setCaption(id, message, message.content.caption.text);
            await addImage(id, message, message.content.document.thumbnail.file);
        }
        else if (contentType == "messageSticker")
        {
            if (!(id in loadedMessages)) // new message
                await createMessage(id, chat, message)
            await setReplyCount(id, message);
            await setCaption(id, message, "");
            var img = await addImage(id, message, message.content.sticker.thumbnail.file);

            // force stickers to be 256x256
            img.setAttribute("style", "width:256px")
        }
    }

    async function loadMessageFromChannel(chat)
    {
        var startID = channels[chat.id].latestMessage
        
        var messageCount = 1;

        var result = await client.send({
            '@type': 'getChatHistory',
            chat_id: chat.id,
            from_message_id: startID, // start from the latest message
            offset: 0, // no offset needed
            limit: messageCount, // number of messages to fetch
        });

        result = await client.send({
            '@type': 'getChatHistory',
            chat_id: chat.id,
            from_message_id: startID, // start from the latest message
            offset: 0, // no offset needed
            limit: messageCount, // number of messages to fetch
        });

        if (result['@type'] === 'messages')
        {
            // means we ran out of messages in the channel entirely?
            // and we should stop checking it for new messages.
            if (getSupportedMessageCount(result) == 0)
            {
                if (channels[chat.id].zeroCount > 3)
                {
                    channels[chat.id].exhausted = true;
                    console.log(channels[chat.id].chat);
                    console.log("^ CHANNEL EXHAUSTED ^. WAS THIS CORRECT?");
                }
                channels[chat.id].zeroCount++;
            }
            for (const message of result.messages)
            {
                channels[chat.id].zeroCount = 0;
                addMessage(message, chat);
            }
        }
    }

    // check 10 times per second (every 100ms)
    var doneLoading = false;
    var sameCount = 0;
    var lastChannelCount;
    var loadCount = 0;
    var startupDelayChecker = setInterval(function ()
    {
        if (bSingleChannel)
        {
            console.log("DONE LOADING!");
            clearInterval(startupDelayChecker);
            doneLoading = true;
            Startup();
            return;
        }
        if (loadCount == 0)
            return;

        if (lastChannelCount != loadCount)
        {
            lastChannelCount = loadCount;
            sameCount = 0;
        }
        else
        {
            sameCount++;
            // If we've held onto the same number of channels for 300ms, that means all the channels have probably been loaded and we can go ahead and start loading messages.
            if (sameCount >= 3)
            {
                console.log("DONE LOADING!");
                clearInterval(startupDelayChecker);
                doneLoading = true;
                Startup();
            }
        }
    }, 100);

    // Called once things are done loading.
    async function Startup()
    {
        DOMmainView.hidden = false;

        // If we want a single channel, but it was not found, search for it.
        if (bSingleChannel && !bSingleChannelFound)
        {
            var bFound = false;
            try
            {
                var chat = await client.send({
                    '@type': 'searchPublicChat',
                    username: channel_name_or_id,
                });

                const supergroup = await client.send({
                    '@type': 'getSupergroup',
                    supergroup_id: chat.type.supergroup_id,
                });

                const supergroupInfo = await client.send({
                    "@type": "getSupergroupFullInfo",
                    supergroup_id: supergroup.id,
                });

                channels[chat.id] = {};
                channels[chat.id].chat = chat;
                channels[chat.id].supergroup = supergroup;
                channels[chat.id].supergroupInfo = supergroupInfo;
                channels[chat.id].zeroCount = 0;

                // load one thing form every channel
                loadMessageFromChannel(chat);
            }
            catch (exceptionVar)
            {
                console.log(exceptionVar);
                DOMchannelList.innerText = "Channel named " + channel_name_or_id + " could not be found."
            }
        }

        // channel not found yet, create it!
        if (!timelineChannel)
        {
            // 1. Create the channel
            const chat = await client.send({
                "@type": "createNewSupergroupChat",
                title: user.username + "'s Telegram Timeline",
                is_channel: true,
                description: "This channel is your Timeline. \nMessages posted or retweeted on from teletime.net will show up here. \n\nThis last number is your user ID and needs to remain at the end of the description for Teletime to work correctly.\n" + user.id,
            });


            // 2. Enable replies by adding a "discussion group".
            const discssionGroup = await client.send({
                "@type": "createNewSupergroupChat",
                title: "Teletime - Discussion Group.",
                is_channel: false,
                description: "This is the discussion group for your telegram timeline. Feel free to ignore it.\n\n" + user.id + "DISCUSS",
            });
            await client.send({
                '@type': 'setChatDiscussionGroup',
                chat_id: chat.id,
                discussion_chat_id: discssionGroup.id,
            });


            // 3. Update the profile picture
            //const uniqueRemoteImageUrl = `$http://212.100.102.124:8000/Coal.png?${Date.now()}`;
            //console.log(uniqueRemoteImageUrl);
            //var setphotoresult = await client.send({
            //    "@type": "setChatPhoto",
            //    chat_id: chatId,
            //    photo: {
            //        "@type": "inputFileGenerated",
            //        original_path: uniqueRemoteImageUrl,
            //        conversion: "",
            //        expected_size: 0,
            //    },
            //});
            //await client.send({
            //    '@type': 'setChatPhoto',
            //    chat_id: chat.id,
            //    photo: {
            //        '@type': 'inputChatPhotoStatic',
            //        photo: {
            //            '@type': 'inputFileGenerated',
            //            original_path: uniqueRemoteImageUrl,
            //            conversion: '',
            //            expected_size: 0,
            //        },
            //    },
            //});

            //// 4. Make it public.
            //var public_username = user.username + "_Timeline6";
            //
            //const isUsernameAvailable = await client.send({
            //    "@type": "checkChatUsername",
            //    chat_id: chat.id,
            //    username: public_username,
            //});
            //
            //if (!isUsernameAvailable)
            //{
            //    // TODO: handle this more gracefully. try again a bunch of times with alernate names?
            //    console.log("failed to make the channel public. PANIC.");
            //    return;
            //}
            //
            //// don't wait for this, as it takes a while.
            //client.send({
            //    "@type": "setSupergroupUsername",
            //    supergroup_id: chat.type.supergroup_id,
            //    username: public_username,
            //});

            timelineChannel = chat;
        }
    }

    async function getChats()
    {
        const result = await client.send({
            '@type': 'getChats',
            chat_list: {
                '@type': 'chatListMain',
            },
            limit: 20,
        });

        return await client.send({
            '@type': 'getChats',
            chat_list: {
                '@type': 'chatListMain',
            },
            limit: 20,
        });
    }

    async function update(data)
    {
        var type = data["@type"];
        DOMlogState.textContent = "state: " + type;

        if (type == "updateAuthorizationState")
        {
            var state = data.authorization_state["@type"];
            DOMlogStateAuth.textContent = "auth_state: " + state;

            if (state == "authorizationStateWaitTdlibParameters")
            {
                client.send({
                    '@type': 'setTdlibParameters',
                    parameters: {
                        '@type': 'tdlibParameters',
                        use_test_dc: false,
                        database_directory: 'tdlib',
                        files_directory: 'tdlib/files',
                        use_file_database: false,
                        use_chat_info_database: true,
                        use_message_database: true,
                        use_secret_chats: false,
                        api_id: 26827015,
                        api_hash: "66daa010ab01961d038809b996b791de",
                        system_language_code: 'en-GB',
                        device_model: 'Web',
                        system_version: 'Unknown',
                        application_version: '1.0',
                        enable_storage_optimizer: true,
                        ignore_file_names: false,
                    },
                });
            }
            else if (state == "authorizationStateWaitEncryptionKey")
            {
                client.send({
                    '@type': 'checkDatabaseEncryptionKey',
                    encryption_key: '', // no encryption
                });

                //client.send({'@type': 'checkDatabaseEncryptionKey', parameters:{client}});
                //await checkDatabaseEncryptionKey(client);
            }
            else if (state == "authorizationStateWaitPhoneNumber")
            {
                DOMphoneVerify.hidden = false;


                while (true)
                {
                    await waitListener(DOMphoneButton, "click");

                    var result = undefined;
                    try
                    {
                        result = await client.send({
                            '@type': 'setAuthenticationPhoneNumber',
                            phone_number: DOMphoneNumber.value,
                            settings: {
                                '@type': 'phoneNumberAuthenticationSettings',
                                allow_flash_call: false,
                                is_current_phone_number: false,
                                allow_sms_retriever_api: false,
                            },
                        });
                    }
                    catch
                    {
                        DOMphoneVerifyError.innerText = "Invalid Phone Number. Make sure you use the country code."
                    }
                    if (result && result["@type"] == 'ok')
                    {
                        break;
                    }
                }

                DOMphoneVerify.hidden = true;
            }
            else if (state == "authorizationStateWaitEmailAddress")
            {

            }
            else if (state == "authorizationStateWaitCode") // waiting for auth code
            {
                DOMcodeVerify.hidden = false;
                while (true)
                {
                    await waitListener(DOMcodeButton, "click");
                    var result = undefined;
                    try
                    {
                        result = await client.send({
                            '@type': 'checkAuthenticationCode',
                            code: DOMcodeNumber.value,
                        });
                    }
                    catch
                    {
                        DOMcodeVerifyError.innerText = "Invalid Code. Check telegram for it."
                    }
                    if (result && result["@type"] == 'ok')
                    {
                        break;
                    }
                }
                DOMcodeVerify.hidden = true;
            }
            else if (state == "authorizationStateWaitRegistration")
            {

            }
            else if (state == "authorizationStateWaitPassword")
            {

            }
            else if (state == "authorizationStateReady")
            {
                getChats();

                // hoist
                user = await client.send({
                    "@type": "getMe",
                });
                DOMlogUserID.textContent = "user_id: " + user.id;
            }
        }
        else if (type == "updateNewChat")
        {
            if (data.chat.type["@type"] == "chatTypeSupergroup" && data.chat.type.is_channel)
            {
                //if (data.chat.title != "Torvid Content")
                //    return;

                if (data.chat.title.includes("Poss"))
                    return;

                const supergroup = await client.send({
                    '@type': 'getSupergroup',
                    supergroup_id: data.chat.type.supergroup_id,
                });

                const supergroupInfo = await client.send({
                    "@type": "getSupergroupFullInfo",
                    supergroup_id: supergroup.id,
                });

                loadCount++;

                // If you are a member
                if (supergroup.status["@type"] === 'chatMemberStatusMember' ||
                    supergroup.status["@type"] === 'chatMemberStatusCreator' ||
                    supergroup.status["@type"] === 'chatMemberStatusAdministrator' ||
                    supergroup.status["@type"] === 'chatMemberStatusRestricted')
                {
                    if (channel_name_or_id)
                    {
                        bSingleChannel = true;
                        var bFound = false;
                        if (channel_name_or_id == supergroup.username)
                            bFound = true;
                        if (channel_name_or_id == data.chat.id)
                            bFound = true;
                    
                        if (!bFound)
                            return;
                        bSingleChannelFound = true;
                    }

                    channels[data.chat.id] = {};
                    channels[data.chat.id].chat = data.chat;
                    channels[data.chat.id].supergroup = supergroup;
                    channels[data.chat.id].supergroupInfo = supergroupInfo;
                    channels[data.chat.id].zeroCount = 0
                    // load one thing form every channel
                    loadMessageFromChannel(data.chat);
                }
                if (supergroup.status["@type"] === 'chatMemberStatusCreator')
                {
                    // the "timeline" channel description ends with your user ID, so it can be found here.
                    // mmmm yes sneaking in metadata my beloved.

                    if (supergroupInfo.description.endsWith(user.id))
                    {
                        timelineChannel = data.chat
                    }
                }
            }
        }
    }

    let options =
    {
        logVerbosityLevel: 1,
        jsLogVerbosityLevel: 3,
        mode: 'wasm',
        prefix: 'tdlib',
        readOnly: false,
        isBackground: false,
        useDatabase: true,
        wasmUrl: `3dee0f934ca1a5946a253599e3e442c6.wasm`,
        onUpdate: update
    };

    var client = new tdweb.default(options)
</script>