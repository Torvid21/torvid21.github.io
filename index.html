<!DOCTYPE html>
<script>
    // Welcome to my single-file webapp, Telegram Timeline!
    // Written by Torivd and ChatGPT.
    // I'm not a web developer by trade. Hopefully I didn't fuck up any security stuff. :)

</script>

<!--
teletime.net

    Now that twitter has no discoverability anymore, we could just move to telegram. :)
    This telegram client takes all the channels you follow and puts them into a single feed.
    Tell me what you think, Poke @Torvid with thoughts and ideas. Especially if you are an experienced web developer <3.

    The whole website is a single ~2kLOC html file containing all the html/css/script, so it should be easy for anyone to audit.
    Only external library is TDweb, a wrapper for the telegram API found here:
    https://www.npmjs.com/package/tdweb

    LIVE version is here: https://teletime.net/
    DEV version is here: http://212.100.102.124:8000/

Let's turn telegram into twitter
Want to escape twitter?
Already use telegram?

This web client takes all the telegram channels you follow and puts them into a single feed.

You can comment, like and retweet (forward) just like on twitter!

:)

[login thingy]

For the techy people,
This is app written in pure JS using TDweb, and is hosted statically on github.io here: [link]

something something preocupied with whether they could

-->

<style>
    /*css to make it look like some terrible amalgum of telegram and twitter.*/
    :root {
        --background: #0E1621;
        --message: #182533;
        --message-hover: #23364a;
        --button-hover: #40678b;
        --user-text: #ffffff;
    }

    body {
        background-color: var(--background);
        color: #FFFFFF;
        font-family: 'Atkinson Hyperlegible', sans-serif; /*I like this font, open to changes though.*/
        font-style: normal;
    }

    /* needed for the hidden attribute to actually work lol */
    [hidden] {
        display: none !important;
    }

    hr {

    }

    message {
        background-color: var(--message);
        display: block;
        margin: 1em;
        border-radius: 1em;
        width: 37em;
        padding: 0.5em;
        height: 50%;
        transition: background-color 0.1s;
    }
        message.comment {
            margin-left: 5em;
            width: 33em;
        }

    message-caption {
        display: block;
        padding: 0.5em;
        white-space: break-spaces;
    }

    message:hover {
        background-color: var(--message-hover);
        cursor: pointer;
    }
    message message-profile img {
        width: 4em;
        height: 4em;
        border-radius: 4em;
    }

    message message-profile span {
        position: relative;
        top: -3.0em;
        left: 0.5em;
        padding: 0.5em;
        color: #72BAFA;
        font-weight: Bold;
    }

    message-profile {
        display: block;
        width: fit-content;
    }
    message-profile span:hover {
        text-decoration: underline;
    }

    message-content {
        left: 4.5em;
        top: -3em;
        position: relative;
        max-width: 29em;
        width: fit-content;
        display: block;
    }

    message-timestamp {
        text-align: right;
        display: block;
        padding: 0.5em;
        font-size: small;
        color: #71767B;
    }

    message-interactions {
        /* margin: 2em; */
        position: relative;
        top: -2em;
        left: 1em;
        white-space: nowrap;
        display: block;
    }

    message-images {
        margin-right: 6em;
        display: grid;
        grid-template-columns: repeat(2, 1fr);
    }

        message-images img {
            margin: 0.1em;
            border-radius: 1em;
            width: 100%;
        }

        message-images video {
            border-radius: 1em;
            width: 100%;
        }

        message-images progress {
            width: 100%;
            display: block;
        }

        message-images img:nth-child(1) {
            grid-column: 1 / 3;
        }

        message-images video:nth-child(1) {
            grid-column: 1 / 3;
        }

    button {
        background-color: #FFFFFF00;
        border: none;
        color: white;
        width: 7.5em;
        /* height: 0em; */
        position: relative;
        display: inline;
        cursor: pointer;
    }

        button span {
            position: absolute;
            top: 0.8em;
            left: 6.5em;
        }

        button:hover::before {
            background-color: var(--button-hover);
        }

        .hovercircle::before {
            content: "";
            background-size: 2.5em 2.5em;
            background-repeat: no-repeat;
            background-position: center;
            width: 2.5em;
            height: 2.5em;
            position: absolute;
            transition: background-color 0.1s;
            border-radius: 2em;
        }

        button::after {
            content: "";
            background-image: url('icon-reply.png');
            background-size: 1.2em 1.2em;
            background-repeat: no-repeat;
            background-position: center;
            width: 2.5em;
            height: 2.5em;
            position: absolute;
        }

    .reply::after {
        background-image: url('icon-reply.png');
    }

    .retweet::after {
        background-image: url('icon-retweet.png');
    }

    .like::after {
        background-image: url('icon-like.png');
    }

    .views::after {
        background-image: url('icon-views.png');
    }

    .share::after {
        background-image: url('icon-share.png');
    }

    .disabled {
        filter: sepia(100%) saturate(0%) brightness(50%);
    }
    pre {
        font-family: 'Atkinson Hyperlegible', sans-serif;
    }
    #creatingTelegramTimelineBackground {
        position: absolute;
        top: 0;
        background-color: #0e1621;
        left: 0;
        width: 100%;
        height: 100%;
    }


    #creatingTelegramTimeline {
        position: fixed;
        top: 50%;
        left: 50%;
        max-width: 30em;
        transform: translate(-50%, -50%);
    }


    .infoModalBackground {
        position: absolute;
        top: 0;
        background-color: #00000080;
        left: 0;
        width: 100%;
        height: 100%;
    }
    .infoModalContent {
        position: fixed;
        top: 50%;
        left: 50%;
        width: 75%;
        transform: translate(-50%, -50%);
        white-space: break-spaces;
        background-color: #0e1621;
        border-radius: 1em;
        padding-left: 4em;
        padding-right: 4em;
    }
    #login {
        /* background-color:
        red; */
        position: fixed;
        top: 50%;
        left: 50%;
        max-width: 30em;
        transform: translate(-50%, -50%);
    }

    #Channel {
    }
        #Channel #ChannelTitle {
            /* background-color:red; */
        }
        #Channel img {
            border-radius: 5em;
            width: 10em;
            height: 10em;
        }
        #Channel #ChannelLink {
        }
        #Channel #ChannelDescription {
        }
        #Channel #ChannelFollowing {
        font-weight: bold;
        }
        #Channel #ChannelFollowers {
        font-weight: bold;
        }

    #phoneVerifyError, #codeVerifyError, #passwordVerifyError {
        background-color: #851515;
        padding: 0.5em;
        margin: 0.5em;
        margin-left: 0;
        margin-right: 0;
        border-radius: 1em;
    }
    #phoneVerifyError:empty, #codeVerifyError:empty, #passwordVerifyError:empty {
        display: none;
    }
    #loginEnterData {
        background-color: #182533;
        border-radius: 1em;
        padding: 1em;
    }
    .entryInput {
        border: 0px solid #ccc;
        font-family: 'Atkinson Hyperlegible', sans-serif;
        /* font-style: normal; */
        font-size: 1em;
        /* box-sizing: border-box; */
        border-radius: 0.5em;
        padding-left: 0.5em;
        color: white;
        background-color: #355779;
        resize: none;
        outline: none;
        height: 1.5em;
        width: 15em;
        width: 15em;
    }

    .entryButton {
        width: 3em;
        height: 2.0em;
        background-color: #355779;
        color: white;
        border-width: 0;
        border-radius: 0.5em;
    }

    .messageInput, .replyInput {
        display: flex;
        flex-direction: row;
        align-items: flex-start; /* Aligns the items vertically */
        gap: 0.2em; /* Optional: Adds space between the textarea and the button */
    }
    #messageTextbox, #replyTextbox {
        width: 38em;
        min-height: 4em; /* Adjust the height as needed */
        resize: vertical; /* Allows vertical resizing of the textarea */
        border: 0px solid #ccc;
        font-family: 'Atkinson Hyperlegible', sans-serif;
        /* font-style: normal; */
        font-size: 1em;
        /* box-sizing: border-box; */
        border-radius: 0.5em;
        padding-left: 0.5em;
        color: white;
        background-color: #355779;
        resize: none;
        outline: none;
    }
    #messageSendButton, #replySendButton {
        width: 5em;
        height: 5em;
        background-color: #355779;
        color: white;
        border-width: 0;
        border-radius: 0.5em;
    }

    input[type=button] {
        width: 8em;
        height: 3em;
        background-color: #355779;
        color: white;
        border-width: 0;
        border-radius: 0.5em;
    }
    /*taken from w3schools*/
    .loader {
        border: 8px solid #182533;
        border-radius: 50%;
        border-top: 8px solid #3498db;
        width: 3em;
        height: 3em;
        /* -webkit-animation: spin 2s linear infinite; */ /* Safari */
        animation: spin 2s linear infinite;
    }
    /* Safari */
    @-webkit-keyframes spin {
        0% {
            -webkit-transform: rotate(0deg);
        }
        100% {
            -webkit-transform: rotate(360deg);
        }
    }
    @keyframes spin {
        0% {
            transform: rotate(0deg);
        }
        100% {
            transform: rotate(360deg);
        }
    }


    a {
        font-family: 'Atkinson Hyperlegible', sans-serif;
        text-decoration: none;
        color: #83CAFF;
    }
        a:link {

        }

        a:visited {

        }

        a:hover {
            text-decoration: underline;
        }

        a:active {

        }

</style>

<head>
    <!--<meta property="og:image" content="http://www.torvid.net/favicon.jpg" />-->
    <meta property="og:title" content="Telegram Timeline" />
    <meta property="og:site_name" content="teletime.net" />
    <meta property="og:description" content="Takes all your telegram channels and puts them into a single feed." />
    <!--<meta http-equiv="refresh" content="0; url=https://torvid21.github.io/index.html">-->
</head>

<body>
    <a href="#"><h1>Telegram Timeline</h1></a>
    <input type="button" value="Technical Info" onclick="document.getElementById('about_modal').removeAttribute('hidden')">
    <hr />

    <div id="status" hidden>
        <p id="state">state: </p>
        <p id="auth_state">auth_state: </p>
        <p id="user_id">user_id: </p>
    </div>

    <div id="login">
        <h1>What?</h1>
        <p>
            This is a Telegram Timeline MVP.<br /><br />
            It takes all the Channels (not Groups or DMs) that you are a member of on Telegram, and puts them all into a singular feed for you, Just like twitter.<br /><br />
            Log-in to telegram below:<br />
        </p>
        <div id="loginEnterData">
            <div id="phoneVerify">
                <label for="phone">Enter phone number:</label><br />
                <input class="entryInput" type="tel" id="phoneNumber" name="phone">
                <input class="entryButton" type="button" id="phoneButton" value="ok">
                <div id="phoneVerifyError"></div>
                <br />
                Make sure to include the regional indicator ex: +46xxxx...
            </div>

            <div id="codeVerify">
                <p>Log-in code sent to your telegram account!</p>
                <label for="phone">Enter it here:</label><br />
                <input class="entryInput" id="codeNumber" name="phone">
                <input class="entryButton" type="button" id="codeButton" value="ok">
                <div id="codeVerifyError"></div>
            </div>

            <div id="passwordVerify">
                <label for="phone">Two-factor auth is enabled, Enter your telegram password:</label><br />
                <input class="entryInput" type="password" id="passwordNumber" name="phone">
                <input class="entryButton" type="button" id="passwordButton" value="ok">
                <div id="passwordVerifyError"></div>
            </div>
        </div>
    </div>

    <div id="mainView">

        <div id="Home">
            <h1 id="HomeTitle">Your Feed</h1>

            <span>What's happening?</span>
            <br />
            <div class="messageInput" , id="messageInput">
                <textarea id="messageTextbox"></textarea>
                <input type="button" id="messageSendButton" value="Send">
            </div>

            <div class="messageInput" id="replyInput" hidden>
                <textarea id="replyTextbox"></textarea>
                <input type="button" id="replySendButton" value="Send">
            </div>
        </div>

        <div id="Channel">
            <img id="ChannelImage" src="missing-picture.png" />
            <h2 id="ChannelTitle"></h2>
            <a id="ChannelLink"></a>
            <p id="ChannelDescription"></p>
            <label id="ChannelFollowers">-</label> followers
            <label id="ChannelFollowing">-</label> following
        </div>

        <div id="Thread">
            <h1 id="ThreadTitle">Thread</h1>
        </div>

        <p id="channelList">
        </p>

        <center>
            <div id="loader" class="loader"></div>
        </center>
    </div>

    <div id="creatingTelegramTimelineBackground" hidden>
        <div id="creatingTelegramTimeline">
            <h1>Creating Telegram Timeline</h1>
            <p>This could take a couple seconds, hold tight.</p>
            <div class="loader"></div>
        </div>
    </div>


    <div id="about_modal" class="infoModalBackground" hidden>
        <div class="infoModalContent">
            <h1>About Teletime</h1>
<input type="button" value="Close" onclick="document.getElementById('about_modal').setAttribute('hidden', '')">
            <p>
This webapp is hosted statically on Github Pages here: <a href="https://github.com/torvid21">https://github.com/torvid21</a>
It's also fully open source!

It's all a single ~2kLOC html file containing all the html/css/script, so it should be easy for anyone to audit. Only external library is TDweb, a wrapper for the telegram API found here:
<a href="https://www.npmjs.com/package/tdweb">https://www.npmjs.com/package/tdweb</a>
LIVE version is here: <a href="https://teletime.net/">https://teletime.net/</a>
DEV version is here: <a href="http://212.100.102.124:8000/">http://212.100.102.124:8000/</a>

TO-DO List:
1. Add tooltips to everything
3. Document download
4. Add DMs in the bottom right
5. Add a list of everyone you currently follow
Maybe have it ask your interests? (memes, furry, cars, food/cooking, etc)
6. Make it so posts are cleverly filtered such that channels that spam a lot show up less
7. Add support for commenting inline, comment threading
8. Support for likes
9. Loading replies as sub-threads
10. Make it load the minithumbnail at the right size immedietly
11. Lightbox and loading high-res for images

<input type="button" value="Close" onclick="document.getElementById('about_modal').setAttribute('hidden', '')">
            </p>
        </div>
    </div>
</body>

<!-- Telegram library-->
<script src="tdweb.js"></script>

<script>
    'use strict'; // first we use strict, because hoisting is unbased

    // then some utility functions
    // from here - https://www.npmjs.com/package/last-seen-ago?activeTab=readme
    function getNiceTime(date)
    {
        let currentTime = Math.floor(Date.now() / 1000) // timestamp in seconds
        let differenceTime = currentTime - Math.floor(date / 1000);
        let seconds = differenceTime;
        let minutes = Math.floor(seconds / 60);
        let hours = Math.floor(seconds / 3600);
        let days = Math.floor(seconds / 86400);
        let weeks = Math.floor(seconds / 604800);
        let months = Math.floor(seconds / 2629440);
        let years = Math.floor(seconds / 31553280);

        if (seconds <= 60)
        {
            return "Just Now";
        }
        else if (minutes <= 60)
        {
            if (minutes == 1) return "one minute ago";
            else return `${minutes} minutes ago`;
        }
        else if (hours <= 24)
        {
            if (hours == 1) return "an hour ago";
            else return `${hours} hrs ago`;
        }
        else if (days <= 7)
        {
            if (days == 1) return "yesterday";
            else return `${days} days ago`;
        }
        else if (weeks <= 4.3)
        {
            if (weeks == 1) return "a week ago";
            else return `${weeks} weeks ago`;
        }
        else if (months <= 12)
        {
            if (months == 1) return "a month ago";
            else return `${months} months ago`;
        }
        else
        {
            if (years == 1) return "one year ago";
            else return `${years} years ago`;
        }
    }

    // copied from stackoverflow, "wait for input"
    // https://stackoverflow.com/questions/51374649/using-async-functions-to-await-user-input-from-onclick
    function waitListener(element, listenerName)
    {
        return new Promise(function (resolve, reject)
        {
            let listener = event =>
            {
                element.removeEventListener(listenerName, listener);
                resolve(event);
            };
            element.addEventListener(listenerName, listener);
        });
    }
    // ChatGPT made this :)
    class AbortController
    {
        constructor()
        {
            this._signals = new Set();
        }

        createSignal()
        {
            const signal = {
                aborted: false,
            };
            this._signals.add(signal);
            return signal;
        }

        abort()
        {
            for (const signal of this._signals)
            {
                signal.aborted = true;
            }
        }
    }
    const abortController = new AbortController();

    async function sendCancelable(argument)
    {
        let abortSignal = abortController.createSignal();

        let thing = await sendGlobal(argument);

        if (abortSignal.aborted) // use exeptions to eject out and not complete the call.
            throw "Async call aborted!"

        return thing;
    }
    async function sendGlobal(argument)
    {
        return await client.send(argument);
    }

    // some global variables :)
    let loadedMessages = [] // groups messages into albums
    let allMessages = [] // does not group messages into albums
    let channels = {}
    let user = undefined; // current user
    let timelineChannel = undefined // your timeline channel

    let status_waitPhoneNumber = "waitPhoneNumber" // wating for phone number
    let status_waitCode = "waitCode" // waiting for code auth
    let status_home = "home" // home, viewing your feed of all messages
    let status_channel = "channel" // viewing a single channel/user
    let status_thread = "thread" // viewing a single message
    let current_status = status_waitPhoneNumber

    //let urlParams = new URLSearchParams(window.location.search);
    //let channel_name_or_id = urlParams.get("channel");
    //let channel_message_id = urlParams.get("message");

    //addEventListener("popstate", (event) => { Startup() });
    //onpopstate = (event) => { Startup() };
    addEventListener("hashchange", (event) => { Startup() });
    onhashchange = (event) => { Startup()  };

    // get html elements
    let DOMlogState = document.getElementById("state");
    let DOMlogStateAuth = document.getElementById("auth_state");
    let DOMlogUserID = document.getElementById("user_id");

    let DOMlogin = document.getElementById("login");
    DOMlogin.hidden = true;

    let DOMphoneVerify = document.getElementById("phoneVerify");
    let DOMphoneVerifyError = document.getElementById("phoneVerifyError");
    let DOMphoneButton = document.getElementById("phoneButton");
    let DOMphoneNumber = document.getElementById("phoneNumber");
    DOMphoneVerify.hidden = true;

    let DOMcodeVerify = document.getElementById("codeVerify");
    let DOMcodeVerifyError = document.getElementById("codeVerifyError");
    let DOMcodeButton = document.getElementById("codeButton");
    let DOMcodeNumber = document.getElementById("codeNumber");
    DOMcodeVerify.hidden = true;
    
    let DOMpasswordVerify = document.getElementById("passwordVerify");
    let DOMpasswordVerifyError = document.getElementById("passwordVerifyError");
    let DOMpasswordButton = document.getElementById("passwordButton");
    let DOMpasswordNumber = document.getElementById("passwordNumber");
    DOMpasswordVerify.hidden = true;

    let DOMmainView = document.getElementById("mainView");
    DOMmainView.hidden = true;
    let DOMtestButton = document.getElementById("testButton");
    let DOMchannelList = document.getElementById("channelList");
    
    let DOMmessageInput = document.getElementById("messageInput");
    let DOMmessageSendButton = document.getElementById("messageSendButton");
    let DOMmessageTextbox = document.getElementById("messageTextbox");

    let DOMreplyInput = document.getElementById("replyInput");
    let DOMreplySendButton = document.getElementById("replySendButton");
    let DOMreplyTextbox = document.getElementById("replyTextbox");


    let DOMhome = document.getElementById("Home");

    let DOMchannel = document.getElementById("Channel");
    let DOMchannelImage = document.getElementById("ChannelImage");
    let DOMchannelTitle = document.getElementById("ChannelTitle");
    let DOMchannelLink = document.getElementById("ChannelLink");
    let DOMchannelDescription = document.getElementById("ChannelDescription");
    let DOMchannelFollowing = document.getElementById("ChannelFollowing");
    let DOMchannelFollowers = document.getElementById("ChannelFollowers");

    let DOMthread = document.getElementById("Thread");


    let DOMloader = document.getElementById("loader");

    let DOMcreatingTelegramTimelineBackground = document.getElementById("creatingTelegramTimelineBackground");

    DOMmessageSendButton.addEventListener("click", async function ()
    {
        if (DOMmessageTextbox.value == "")
            return;
        let text = DOMmessageTextbox.value
        DOMmessageTextbox.value = "";
        await createTimelineChannel();
        sendMessage(text, timelineChannel.id);
    });

    DOMmessageTextbox.addEventListener("keydown", async function (event)
    {
        if (event.shiftKey)
            return;
        if (event.ctrlKey)
            return;
        if (event.key === "Enter")
        {
            event.preventDefault();

            if (DOMmessageTextbox.value == "")
                return;
            await createTimelineChannel();
            let text = DOMmessageTextbox.value
            DOMmessageTextbox.value = "";
            sendMessage(text, timelineChannel.id);
        }
    });

    let global_chat_id = 0;
    let global_reply_id = 0;
    let global_message_thread_id = 0;
    DOMreplySendButton.addEventListener("click", function ()
    {
        if (DOMreplyTextbox.value == "")
            return;
        DOMreplyInput.hidden = true;
        let text = DOMreplyTextbox.value
        DOMreplyTextbox.value = "";
        sendMessage(text, global_chat_id, global_reply_id, global_message_thread_id);
        // TODO: open the thread
    });
    DOMreplyTextbox.addEventListener("keydown", function (event)
    {
        if (event.shiftKey)
            return;
        if (event.ctrlKey)
            return;
        if (event.key === "Enter")
        {
            event.preventDefault();

            if (DOMreplyTextbox.value == "")
                return;
            DOMreplyInput.hidden = true;
            let text = DOMreplyTextbox.value
            DOMreplyTextbox.value = "";
            sendMessage(text, global_chat_id, global_reply_id, global_message_thread_id);
            // TODO: open the thread
        }
    });

    async function sendMessage(contents, chat_id, reply_to_message_id = 0, message_thread_id = 0)
    {
        // Send a text message to the channel
        let result = await sendCancelable({
            "@type": "sendMessage",
            chat_id: chat_id,
            reply_to_message_id: reply_to_message_id,
            message_thread_id: message_thread_id,
            input_message_content: {
                "@type": "inputMessageText",
                text: {
                    "@type": "formattedText",
                    text: contents,
                },
                disable_web_page_preview: false,
                clear_draft: true,
            },
        });

        Startup();
    }

    let scrollChecker = setInterval(function ()
    {
        scroll = document.body.offsetHeight - (window.innerHeight + Math.ceil(window.pageYOffset));
        if (scroll < 1000)
        {
            loadMore();
        }
    }, 250);

    async function setProfilePicEventually(img, photo)
    {
        if (!photo)
        {
            img.src = "missing-picture.png"
            return;
        }
    
        // 1. immedietly set it to the mini pic
        img.src = "data:image/jpeg;base64," + photo.minithumbnail.data;
    
        // 2. slowly download the full pic and set it.
        img.src = await loadImage(photo.small);
    }

    // Creates a message and appends it to the DOM
    async function createMessage(id, chat, message, use_hiding = true, bIsComment = false)
    {
        let date = message.date;
        // Create and append the message tag to the DOM immedietly
        let firstChildThatIsOlderThanNewMessage = undefined
        for (let child of DOMchannelList.children)
        {
            if (date > child.getAttribute("timestamp"))
            {
                firstChildThatIsOlderThanNewMessage = child
                break;
            }
        }
        let DOMmessage = document.createElement("message");

        if (!bIsComment)
        {
            //if (firstChildThatIsOlderThanNewMessage)
            //    DOMchannelList.insertBefore(DOMmessage, firstChildThatIsOlderThanNewMessage.nextSibling);
            //else
            DOMchannelList.appendChild(DOMmessage);
        }

        let forwardcount = 0
        let viewcount = 0
        if (message.interaction_info)
        {
            message.interaction_info.forward_count;
            message.interaction_info.view_count;
        }

        let bCommentsEnabled = channels[chat.id].supergroup.has_linked_chat;

        let retweet_message = undefined
        let title = undefined;
        let profile_pic = undefined;
        let username = undefined;

        if (message.forward_info) // if it was forwarded
        {
            // forwarded from a user
            if (message.forward_info.origin["@type"] == "messageForwardOriginUser")
            {
                let user = await sendCancelable({
                    "@type": "getUser",
                    "user_id": message.forward_info.origin.sender_user_id,
                });
                username = user.username;
                profile_pic = user.profile_photo;
            }
            else if (message.forward_info.origin["@type"] == "messageForwardOriginChannel")
            {
                let channel = channels[message.forward_info.origin.chat_id];
                if (channel)
                {
                    profile_pic = channel.chat.photo;
                    title = channel.chat.title
                    username = channel.supergroup.username
                    if (!username)
                        username = channel.chat.id
                }
            }

            retweet_message = chat.title;
        }
        else
        {
            if (bIsComment)
            {
                if (message.sender_id["@type"] == "messageSenderUser")
                {
                    let user = await sendCancelable({
                        "@type": "getUser",
                        "user_id": message.sender_id.user_id,
                    });

                    if (user.profile_photo)
                        profile_pic = user.profile_photo;
                    title = user.first_name;
                    username = user.username;
                }
                else if (message.sender_id["@type"] == "messageSenderChat")
                {
                    profile_pic = chat.photo;
                    title = chat.title
                    let channelSupergroup = await sendCancelable({
                        '@type': 'getSupergroup',
                        supergroup_id: chat.type.supergroup_id,
                    });
                    username = channelSupergroup.username
                    if (!username)
                        username = channel.chat.id
                }
            }
            else
            {
                if (channels[chat.id].chat.photo)
                    profile_pic = channels[chat.id].chat.photo;
                title = chat.title;
                username = channels[chat.id].supergroup.username
                if (!username)
                    username = chat.id
            }
        }

        loadedMessages[id] = {};
        if (loadedMessages[id].messages == undefined)
            loadedMessages[id].messages = []
        loadedMessages[id].messages.push(message);

        if (channels[chat.id].latestDOMmessage)
        {
            DOMloader.hidden = true;
            channels[chat.id].latestDOMmessage.hidden = false;
            channels[chat.id].latestDOMmessage.parentNode.appendChild(channels[chat.id].latestDOMmessage); // move it to the bottom
        }
        // do this after rearranging so the comments always show up last
        if (bIsComment)
        {
            DOMmessage.setAttribute("class", "comment");
            DOMchannelList.appendChild(DOMmessage);
        }

        if (!bCommentsEnabled)
            DOMloader.hidden = true;

        if(use_hiding)
            DOMmessage.hidden = true;

        channels[chat.id].latestDOMmessage = DOMmessage;
        loadedMessages[id].DOMmessage = DOMmessage;

        DOMmessage.setAttribute("timestamp", date)
        if (retweet_message)
        {
            loadedMessages[id].DOMretweeted_by = loadedMessages[id].DOMmessage.appendChild(document.createElement("message-retweet"));
            loadedMessages[id].DOMmessage.textContent = chat.title + " retweeted"
        }

        let DOMprofile              = DOMmessage.appendChild(document.createElement("message-profile"));
        let DOMprofileImg           = DOMprofile.appendChild(document.createElement("img"));
        let DOMprofileUsername      = DOMprofile.appendChild(document.createElement("span"));
        loadedMessages[id].DOMprofile           = DOMprofile;
        loadedMessages[id].DOMprofileImg        = DOMprofileImg;
        loadedMessages[id].DOMprofileUsername   = DOMprofileUsername;

        let DOMcontent       = DOMmessage.appendChild(document.createElement("message-content"));
        let DOMcaption       = DOMcontent.appendChild(document.createElement("message-caption"));
        let DOMimages        = DOMcontent.appendChild(document.createElement("message-images"));
        let DOMinteractions  = DOMmessage.appendChild(document.createElement("message-interactions"));
        loadedMessages[id].DOMcontent       = DOMcontent;
        loadedMessages[id].DOMcaption       = DOMcaption;
        loadedMessages[id].DOMimages        = DOMimages;
        loadedMessages[id].DOMinteractions = DOMinteractions;
        loadedMessages[id].DOMreply = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        loadedMessages[id].DOMreplyText = loadedMessages[id].DOMreply.appendChild(document.createElement("span"))
        loadedMessages[id].DOMreplyText.textContent = 0;

        loadedMessages[id].DOMretweet = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        loadedMessages[id].DOMretweet.setAttribute("class", "retweet hovercircle");
        loadedMessages[id].DOMretweet.appendChild(document.createElement("span")).textContent = forwardcount;

        DOMmessage.addEventListener("click", async function (event)
        {
            let bHitMessage = false;
            let bHitProfile = false;
            if (event.target == DOMmessage)
                bHitMessage = true;
            if (event.target == DOMcontent)
                bHitMessage = true;
            if (event.target == DOMimages)
                bHitMessage = true;
            if (event.target == DOMprofile)
                bHitMessage = true;

            if (event.target == DOMprofileImg)
                bHitProfile = true;
            if (event.target == DOMprofileUsername)
                bHitProfile = true;

            if (bHitMessage) // go to message / comments
            {
                history.pushState({}, "Go to thread", "#channel=" + username + "#message=" + message.id)
                Startup()
            }
            else if (bHitProfile) // go to profile
            {
                history.pushState({}, "Go to channel or user", "#channel=" + username)
                Startup()
            }
        });

        let messageThread = null;
        try
        {
            messageThread = await sendCancelable({
                '@type': 'getMessageThread',
                chat_id: chat.id,
                message_id: message.id,
            });
        }
        catch (err)
        {
            console.log(err)
        }

        if (bCommentsEnabled)
        {
            loadedMessages[id].DOMreply.setAttribute("class", "reply hovercircle");
            loadedMessages[id].DOMreply.addEventListener("click", function (_DOMmessage, chat, message, thread)
            {
                let channel = channels[chat.id];

                return async function ()
                {
                    if (thread)
                    {
                        global_chat_id = thread.chat_id;
                        global_reply_id = thread.messages[0].id;
                        global_message_thread_id = thread.message_thread_id;
                    }
                    else
                    {
                        global_chat_id = message.chat_id;
                        global_reply_id = message.id;
                        global_message_thread_id = message.message_thread_id;
                    }
                    DOMreplyInput.hidden = false;
                    _DOMmessage.appendChild(DOMreplyInput);
                }
            }(DOMmessage, chat, message, messageThread))
        }
        else
        {
            loadedMessages[id].DOMreply.setAttribute("class", "reply disabled");
        }
        loadedMessages[id].DOMretweet.addEventListener("click", function (inner_id, inner_chatId)
        {
            return async function ()
            {
                await createTimelineChannel();

                let fwd = loadedMessages[inner_id].messages;
                let msgs = [];
                for (let i = 0; i < fwd.length; i++)
                {
                    msgs.push(fwd[i].id)
                }
                await sendCancelable({
                    '@type': 'forwardMessages',
                    from_chat_id: inner_chatId,
                    chat_id: timelineChannel.id,
                    message_ids: msgs,
                });

                Startup();
            }
        }(id, chat.id));
        
        loadedMessages[id].DOMlike = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        loadedMessages[id].DOMlike.setAttribute("class", "like hovercircle");
        loadedMessages[id].DOMlike.appendChild(document.createElement("span")).textContent = 0;

        let DOMviews = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        DOMviews.setAttribute("class", "views hovercircle");
        DOMviews.appendChild(document.createElement("span")).textContent = viewcount;

        //console.log(message)
        let DOMshare = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        DOMshare.setAttribute("class", "share hovercircle");
        DOMshare.appendChild(document.createElement("span")).textContent = ""
        DOMshare.addEventListener("click", function (inner_id, inner_chatId)
        {
            return async function ()
            {
                let result = await sendCancelable({
                    '@type': 'getMessageLink',
                    chat_id: inner_chatId,
                    message_id: inner_id,
                });
                console.log(result);
                window.open(result.link);
            }
            
        }(message.id, chat.id));

        loadedMessages[id].DOMtimestamp = DOMmessage.appendChild(document.createElement("message-timestamp"));

        // async function that sets the picture later when it feels like it. :)
        //setProfilePicEventually(loadedMessages[id].DOMprofileImg, profile_pic)
        setProfilePicEventually(loadedMessages[id].DOMprofileImg, profile_pic);

        loadedMessages[id].DOMprofileUsername.textContent = title
        loadedMessages[id].DOMtimestamp.textContent = getNiceTime(new Date(date * 1000));
    }

    async function loadMore()
    {
        if (!doneLoading)
            return;

        if (current_status == status_thread) // If in this state, we should read comments instead.
            return;

        //for (let j = 0; j < 5; j++)
        {
            let smallest = undefined;
            let smallestTimestamp = 0;
            // find the channel with the most recent message and load that one
            for (let i = 0; i < Object.keys(channels).length; i++)
            {
                let channel = channels[Object.keys(channels)[i]];
                if (channel.exhausted)
                    continue;

                let timestamp = channel.latestMessageTimestamp
                if (timestamp > smallestTimestamp)
                {
                    smallestTimestamp = timestamp
                    smallest = channel;
                }
            }

            if (smallest)
                loadMessageFromChannel(smallest.chat)
        }
    }

    let imageCache = {};

    async function loadImage(file)
    {
        return loadFile(file, "image/png", null);
    }
    async function loadFile(file, mime_type, setProgress)
    {
        if (!imageCache.hasOwnProperty(file.id))
        {
            let blob = await loadFileBlob(file, mime_type, setProgress)
            imageCache[file.id] = URL.createObjectURL(blob);
        }
        return imageCache[file.id];

        //let blob = await loadFileBlob(file, mime_type, setProgress)
        //return URL.createObjectURL(blob);
    }
    async function loadFileBlob(file, mime_type, setProgress)
    {
        // TODO: add support for streaming large video files.

        let CHUNK_SIZE = 1024 * 64; // 64KB

        let offset = 0;
        let fileSize = file.size;

        let chunks = [];
        while (true)
        {
            let DLSize = Math.min(CHUNK_SIZE, fileSize - offset)

            if (fileSize == 0) // unknown filesize, just start downloading it
                DLSize = CHUNK_SIZE;

            if (DLSize <= 0)
                break;

            if (!file.is_downloading_completed)
            {
                let result = await sendCancelable({
                    '@type': 'downloadFile',
                    file_id: file.id,
                    priority: 1,
                    offset: offset, // where in the file to start downloading
                    limit: DLSize, // how much to download in bytes
                    synchronous: true, // download the file synchronously
                });
                fileSize = result.size;
            }

            let result2 = await sendCancelable({
                '@type': 'readFilePart',
                file_id: file.id,
                offset: offset,
                count: Math.min(CHUNK_SIZE, fileSize - offset),
            });

            let fileData = result2.data;
            chunks.push(fileData);

            if (setProgress)
                setProgress(offset, fileSize);

            offset += CHUNK_SIZE;
        }
        let blob = new Blob(chunks, { type: mime_type });
        if (setProgress)
            setProgress(fileSize, fileSize);

        return blob;
    }

    async function setReplyCount(id, message)
    {
        if (loadedMessages[id].DOMreplyText.textContent == 0 && message.interaction_info && message.interaction_info.reply_info)
            loadedMessages[id].DOMreplyText.textContent = message.interaction_info.reply_info.reply_count;
    }
    async function addImage(id, message, image)
    {
        let images = loadedMessages[id].DOMimages;

        let img = document.createElement('img');

        images.prepend(img);


        if (image.sizes) // normal image
        {
            img.src = "data:image/jpeg;base64," + image.minithumbnail.data;
            loadImage(image.sizes[0].photo).then((src) =>
            {
                img.src = src;
            })
        }
        else // document
        {
            img.src = "data:image/jpeg;base64," + image.minithumbnail.data;
            loadImage(image.thumbnail.file).then((src) =>
            {
                img.src = src;
            })
        }
    }
    async function addVideo(id, message, video, thumbnail, controls)
    {
        let DOMvideo = document.createElement('video');
        let images = loadedMessages[id].DOMimages;
        images.prepend(DOMvideo);

        
        if (controls)
        {
            DOMvideo.setAttribute("controls", "");
        }
        else
        {
            DOMvideo.setAttribute("autoplay", "");
            DOMvideo.setAttribute("loop", "");
        }

        DOMvideo.setAttribute("poster", "data:image/jpeg;base64," + thumbnail.minithumbnail.data);
        if (thumbnail["@type"] == "video")
        {
            loadImage(thumbnail.thumbnail.file).then((src) =>
            {
                DOMvideo.setAttribute("poster", src);
            })
        }
        else if (thumbnail["@type"] == "animation")
        {
            loadImage(thumbnail.thumbnail.file).then((src) =>
            {
                DOMvideo.setAttribute("poster", src);
            })
        }

        let progress = images.appendChild(document.createElement('progress'));
        let source = document.createElement('source');
        DOMvideo.appendChild(source);
        loadFile(video, "video/mp4", function (value, max)
        {
            if (value == max) // done
            {
                progress.hidden = true;
            }
            progress.setAttribute("value", value)
            progress.setAttribute("max", max)
        }).then((src) =>
        {
            source.setAttribute("src", src);
        });

    }
    async function setCaption(id, message, caption)
    {
        if (loadedMessages[id].DOMcaption.textContent == "")
            loadedMessages[id].DOMcaption.textContent = caption;
    }
    function isMessageSupported(message)
    {
        if (message.id in allMessages) // we got the same message twice. reject it!
            return false;

        let contentType = message.content["@type"];
        if (contentType == "messageText")
            return true;
        else if (contentType == "messagePhoto")
            return true;
        else if (contentType == "messageVideo")
            return true;
        else if (contentType == "messageAnimation")
            return true;
        else if (contentType == "messageDocument")
            return true;
        //else if (contentType == "messageSticker")
        //    return true;
        return false;
    }
    function getSupportedMessageCount(result)
    {
        let count = 0
        for (let message of result.messages)
        {
            if (isMessageSupported(message))
                count++;
        }
        return count;
    }


    // high level function to download and add a message to the timeline.
    async function addMessage(message, chat, use_hiding = true, bIsComment = false)
    {
        allMessages[message.id] = {};

        let id = message.media_album_id;
        if (message.media_album_id == 0)
            id = message.id;

        channels[chat.id].latestMessage = message.id;
        channels[chat.id].latestMessageTimestamp = message.date;

        let contentType = message.content["@type"];
        if (contentType == "messageText")
        {
            if (!(id in loadedMessages)) // new message
                await createMessage(id, chat, message, use_hiding, bIsComment);
            await setReplyCount(id, message);
            await setCaption(id, message, message.content.text.text);
        }
        else if (contentType == "messagePhoto")
        {
            if (!(id in loadedMessages)) // new message
                await createMessage(id, chat, message, use_hiding, bIsComment)
            await setReplyCount(id, message);
            await setCaption(id, message, message.content.caption.text);
            await addImage(id, message, message.content.photo);//.sizes[0].photo
        }
        else if (contentType == "messageVideo")
        {
            if (!(id in loadedMessages)) // new message
                await createMessage(id, chat, message, use_hiding, bIsComment)
            await setReplyCount(id, message);
            await setCaption(id, message, message.content.caption.text);
            await addVideo(id, message, message.content.video.video, message.content.video, true)
        }
        else if (contentType == "messageAnimation")
        {
            if (!(id in loadedMessages)) // new message
                await createMessage(id, chat, message, use_hiding, bIsComment)
            await setReplyCount(id, message);
            await setCaption(id, message, message.content.caption.text);
            await addVideo(id, message, message.content.animation.animation, message.content.animation, false)
        }
        else if (contentType == "messageDocument")
        {
            if (!(id in loadedMessages)) // new message
                await createMessage(id, chat, message, use_hiding, bIsComment)
            await setReplyCount(id, message);
            await setCaption(id, message, message.content.caption.text);
            await addImage(id, message, message.content.document);//.thumbnail.file
        }
        //else if (contentType == "messageSticker")
        //{
        //    if (!(id in loadedMessages)) // new message
        //        await createMessage(id, chat, message, use_hiding, bIsComment)
        //    await setReplyCount(id, message);
        //    await setCaption(id, message, "");
        //    let img = await addImage(id, message, message.content.sticker.thumbnail.file);
        //
        //    // force stickers to be 256x256
        //    img.setAttribute("style", "width:256px")
        //}
    }

    async function loadSingleMessage(chat, message_id)
    {
        let message = await sendCancelable({
            '@type': 'getMessage',
            chat_id: chat.id,
            message_id: message_id,
        });

        await addMessage(message, chat, false);

        return message;
    }

    async function loadMessageFromChannel(chat)
    {
        let startID = channels[chat.id].latestMessage
        
        let messageCount = 1;

        let result = await sendCancelable({
            '@type': 'getChatHistory',
            chat_id: chat.id,
            from_message_id: startID, // start from the latest message
            offset: 0, // no offset needed
            limit: messageCount, // number of messages to fetch
        });

        result = await sendCancelable({
            '@type': 'getChatHistory',
            chat_id: chat.id,
            from_message_id: startID, // start from the latest message
            offset: 0, // no offset needed
            limit: messageCount, // number of messages to fetch
        });

        if (result['@type'] === 'messages')
        {
            // means we ran out of messages in the channel entirely?
            // and we should stop checking it for new messages.
            if (getSupportedMessageCount(result) == 0)
            {
                if (channels[chat.id].zeroCount > 3)
                {
                    channels[chat.id].exhausted = true;
                    console.log(channels[chat.id].chat);
                    console.log("^ CHANNEL EXHAUSTED ^. WAS THIS CORRECT?");
                }
                channels[chat.id].zeroCount++;
            }
            for (let message of result.messages)
            {
                channels[chat.id].zeroCount = 0;
                addMessage(message, chat);
            }
        }
    }

    // check 10 times per second (every 100ms)
    let doneLoading = false;
    let sameCount = 0;
    let lastChannelCount;
    let loadCount = 0;
    let startupDelayChecker = setInterval(function ()
    {
        if (current_status == status_channel || current_status == status_thread)
        {
            console.log("DONE LOADING!");
            clearInterval(startupDelayChecker);
            doneLoading = true;
            Startup();
            return;
        }

        if (loadCount == 0)
            return;

        if (lastChannelCount != loadCount)
        {
            lastChannelCount = loadCount;
            sameCount = 0;
        }
        else
        {
            sameCount++;
            // If we've held onto the same number of channels for 300ms, that means all the channels have probably been loaded and we can go ahead and start loading messages.
            if (sameCount >= 3)
            {
                console.log("DONE LOADING!");
                clearInterval(startupDelayChecker);
                doneLoading = true;
                Startup();
            }
        }
    }, 100);

    let rCountGlobal = 0;
    // Called once things are done loading.
    async function Startup()
    {
        rCountGlobal++;

        abortController.abort(); // abort all async functions

        DOMloader.hidden = false;

        let channel_name_or_id = null;
        let channel_message_id = null;
        let splitString = window.location.hash.split("#");
        let split0 = splitString[0];
        let split1 = splitString[1];
        let split2 = splitString[2];
        console.log(splitString);
        if (split1)
        {
            let channelSplit = splitString[1].split("=");
            if (channelSplit[0] == "channel")
                channel_name_or_id = channelSplit[1]
        }
        if (split2)
        {
            let messageSplit = splitString[2].split("=");
            if (messageSplit[0] == "message")
                channel_message_id = messageSplit[1]
        }


        DOMmainView.hidden = false;
        DOMlogin.hidden = true;
        DOMhome.hidden = true;
        DOMchannel.hidden = true;
        DOMthread.hidden = true;

        current_status = status_home;
        if (channel_name_or_id)
        {
            current_status = status_channel

            if (channel_message_id)
                current_status = status_thread
        }
        if (current_status == status_home)
            DOMhome.hidden = false;
        if (current_status == status_channel)
            DOMchannel.hidden = false;
        if (current_status == status_thread)
            DOMthread.hidden = false;

        document.body.appendChild(DOMreplyInput); // move out to safety
        DOMchannelList.innerHTML = ""; // nuke
        loadedMessages = []; // nuke
        allMessages = []; // nuke
        for (let i = 0; i < Object.keys(channels).length; i++)
        {
            let channel = channels[Object.keys(channels)[i]];
            channel.latestDOMmessage = null;
            channel.latestMessage = null;
            channel.latestMessageTimestamp = null;
            channel.zeroCount = 0;
            channel.exhausted = false;
        }

        if (current_status == status_home)
        {
            for (let i = 0; i < Object.keys(channels).length; i++)
            {
                let channel = channels[Object.keys(channels)[i]];
                if (channel.bIsDiscussion)
                    continue;

                // load one thing form every channel
                loadMessageFromChannel(channel.chat);
            }
        }

        // If we want a single channel, but it was not found, search for it.
        if (current_status == status_channel || current_status == status_thread)
        {
            let chat = undefined
            try
            {
                console.log(`Trying to load channel ${channel_name_or_id} as chat ID`);
                chat = await sendCancelable({
                    '@type': 'getChat',
                    chat_id: channel_name_or_id,
                });
            }
            catch (exceptionVar)
            {
                try
                {
                    console.log(`Trying to load channel ${channel_name_or_id} as public chat by Name`);
                    chat = await sendCancelable({
                        '@type': 'searchPublicChat',
                        username: channel_name_or_id,
                    });
                }
                catch (exceptionVar)
                {
                    console.log(`Loading chat failed.`);
                }
            }

            if (chat)
            {
                let supergroup = await sendCancelable({
                    '@type': 'getSupergroup',
                    supergroup_id: chat.type.supergroup_id,
                });

                let supergroupInfo = await sendCancelable({
                    "@type": "getSupergroupFullInfo",
                    supergroup_id: supergroup.id,
                });

                channels[chat.id] = {};
                channels[chat.id].chat = chat;
                channels[chat.id].supergroup = supergroup;
                channels[chat.id].supergroupInfo = supergroupInfo;
                channels[chat.id].zeroCount = 0;

                // load one thing form every channel
                if (current_status == status_thread)
                {
                    // load messages until the 
                    // load the first message
                    let message = await sendCancelable({
                        '@type': 'getMessage',
                        chat_id: chat.id,
                        message_id: channel_message_id,
                    });
                    let resultMessage = message;

                    // It's an album, albums can contain max 10 items.
                    // So we load 10 messages and loop through them to find the one that contains the data we want.
                    if (message.media_album_id)
                    {
                        // TODO: stats liek viewcount on this
                        // TODO: grabbing 10 messages like this to load a gallery is
                        //       a much nicer solution than folding them in one by one.
                        let albumID = message.media_album_id;
                        let result = await sendCancelable({
                            '@type': 'getChatHistory',
                            chat_id: chat.id,
                            from_message_id: 0,
                            offset: 0,
                            limit: 10,
                        });
                        result = await sendCancelable({
                            '@type': 'getChatHistory',
                            chat_id: chat.id,
                            from_message_id: 0,
                            offset: 0,
                            limit: 10,
                        });
                        console.log(result);
                        for (let message of result.messages)
                        {
                            if (message.media_album_id == albumID)
                                resultMessage = message
                            else
                                break;
                        }
                    }

                    // load comments
                    let result = null;
                    try
                    {
                        console.log("get START");
                        console.log(channels[chat.id]);
                        console.log(resultMessage);
                        result = await sendCancelable({
                            '@type': 'getMessageThreadHistory',
                            chat_id: chat.id,
                            message_id: resultMessage.id,
                            from_message_id: 0,
                            offset: 0,
                            limit: 10,
                        });
                        console.log("get DONE");
                    }
                    catch (err)
                    {
                        console.log("get ERROR");
                        console.log(err)
                    }

                    if (result && result.messages[0])
                    {
                        // If a thread was found, to be able to reply to the main message
                        // we need to use the main message from the *thread*, not from the *channel*.
                        // we find the *thread* message by asking the first reply what it was replying to.
                        let discussionChat = await sendCancelable({
                            '@type': 'getChat',
                            chat_id: result.messages[0].reply_in_chat_id,
                        });

                        let message = await loadSingleMessage(discussionChat, result.messages[0].reply_to_message_id)

                        for (let message of result.messages)
                        {
                            addMessage(message, chat, false, true);
                        }
                    }
                    else
                    {
                        // if thread was empty, just load the one message directly.
                        let message = await loadSingleMessage(chat, channel_message_id)
                    }

                }
                else
                {
                    let channel = channels[chat.id]
                    DOMchannelDescription.innerText = channel.supergroupInfo.description;
                    DOMchannelTitle.innerText = channel.chat.title;
                    DOMchannelLink.innerText = "t.me/" + channel.supergroup.username
                    DOMchannelLink.setAttribute("href", "https://t.me/" + channel.supergroup.username);
                    DOMchannelFollowers.innerText = channel.supergroup.member_count;
                    DOMchannelFollowing.innerText = "-";
                    setProfilePicEventually(DOMchannelImage, channel.chat.photo)

                    loadMessageFromChannel(chat);
                }
            }
            else
            {
                DOMchannelList.innerText = "Channel named " + channel_name_or_id + " could not be found."
            }
        }
    }

    async function createTimelineChannel()
    {
        //// If we are viewing a single channel or message, we can't post to our own timeline.
        //if (bSingleChannel || bSingleMessage)
        //    return;
        //
        //// channel not found yet, create it!
        if (timelineChannel)
            return;

        DOMcreatingTelegramTimelineBackground.hidden = false;

        // 1. Create the channel
        let chat = await sendCancelable({
            "@type": "createNewSupergroupChat",
            title: user.username + "'s Telegram Timeline",
            is_channel: true,
            description: "This is " + user.username + "'s Telegram timeline!\n\nThis number is your user ID and needs to remain here for Teletime to work correctly.\n" + user.id,
        });
        
        
        // 2. Enable replies by adding a "discussion group".
        let discssionGroup = await sendCancelable({
            "@type": "createNewSupergroupChat",
            title: "Teletime - Discussion Group.",
            is_channel: false,
            description: "This is the discussion group for your telegram timeline. Feel free to ignore it.\n\n" + user.id + "DISCUSS",
        });
        await sendCancelable({
            '@type': 'setChatDiscussionGroup',
            chat_id: chat.id,
            discussion_chat_id: discssionGroup.id,
        });


        // 3. Update the profile picture
        //let uniqueRemoteImageUrl = `$http://212.100.102.124:8000/Coal.png?${Date.now()}`;
        //console.log(uniqueRemoteImageUrl);
        //let setphotoresult = await sendCancelable({
        //    "@type": "setChatPhoto",
        //    chat_id: chatId,
        //    photo: {
        //        "@type": "inputFileGenerated",
        //        original_path: uniqueRemoteImageUrl,
        //        conversion: "",
        //        expected_size: 0,
        //    },
        //});
        //await sendCancelable({
        //    '@type': 'setChatPhoto',
        //    chat_id: chat.id,
        //    photo: {
        //        '@type': 'inputChatPhotoStatic',
        //        photo: {
        //            '@type': 'inputFileGenerated',
        //            original_path: uniqueRemoteImageUrl,
        //            conversion: '',
        //            expected_size: 0,
        //        },
        //    },
        //});

        // 4. Make it public.
        let public_username = user.username + "_Timeline";
        
        let isUsernameAvailable = await sendCancelable({
            "@type": "checkChatUsername",
            chat_id: chat.id,
            username: public_username,
        });
        
        if (!isUsernameAvailable)
        {
            // TODO: handle this more gracefully. try again a bunch of times with alernate names?
            console.log("failed to make the channel public. PANIC.");
            return;
        }
        
        // don't wait for this, as it takes a while.
        sendCancelable({
            "@type": "setSupergroupUsername",
            supergroup_id: chat.type.supergroup_id,
            username: public_username,
        });

        timelineChannel = chat;

        sendMessage("Hello!\n\nThis channel is your Timeline.\n Think of it kind of like your twitter timeline. 'Retweets' and 'Tweets' on teletime.net will show up here.", timelineChannel.id);

        DOMcreatingTelegramTimelineBackground.hidden = true;
    }

    async function getChats()
    {
        let result = await sendCancelable({
            '@type': 'getChats',
            chat_list: {
                '@type': 'chatListMain',
            },
            limit: 20,
        });

        return await sendCancelable({
            '@type': 'getChats',
            chat_list: {
                '@type': 'chatListMain',
            },
            limit: 20,
        });
    }

    async function update(data)
    {
        let type = data["@type"];
        DOMlogState.textContent = "state: " + type;

        if (type == "updateAuthorizationState")
        {
            let state = data.authorization_state["@type"];
            DOMlogStateAuth.textContent = "auth_state: " + state;

            if (state == "authorizationStateWaitTdlibParameters")
            {
                sendGlobal({
                    '@type': 'setTdlibParameters',
                    parameters: {
                        '@type': 'tdlibParameters',
                        use_test_dc: false,
                        database_directory: 'tdlib',
                        files_directory: 'tdlib/files',
                        use_file_database: false,
                        use_chat_info_database: true,
                        use_message_database: true,
                        use_secret_chats: false,
                        api_id: 26827015,
                        api_hash: "66daa010ab01961d038809b996b791de",
                        system_language_code: 'en-GB',
                        device_model: 'Web',
                        system_version: 'Unknown',
                        application_version: '1.0',
                        enable_storage_optimizer: true,
                        ignore_file_names: false,
                    },
                });
            }
            else if (state == "authorizationStateWaitEncryptionKey")
            {
                sendGlobal({
                    '@type': 'checkDatabaseEncryptionKey',
                    encryption_key: '', // no encryption
                });

                //sendCancelable({'@type': 'checkDatabaseEncryptionKey', parameters:{client}});
                //await checkDatabaseEncryptionKey(client);
            }
            else if (state == "authorizationStateWaitPhoneNumber")
            {
                DOMlogin.hidden = false;
                DOMphoneVerify.hidden = false;

                while (true)
                {
                    await waitListener(DOMphoneButton, "click");
                    DOMphoneVerify.hidden = true;

                    let result = undefined;
                    try
                    {
                        result = await sendGlobal({
                            '@type': 'setAuthenticationPhoneNumber',
                            phone_number: DOMphoneNumber.value.replace(/[^+\d]+/g, ""),
                            settings: {
                                '@type': 'phoneNumberAuthenticationSettings',
                                allow_flash_call: false,
                                is_current_phone_number: false,
                                allow_sms_retriever_api: false,
                            },
                        });
                    }
                    catch
                    {
                        DOMphoneVerifyError.innerHTML = "Invalid Phone Number. <br/>Make sure you use the country code!"
                        DOMphoneVerify.hidden = false;
                    }
                    DOMphoneNumber.value = "";
                    if (result && result["@type"] == 'ok')
                    {
                        break;
                    }
                }

                DOMphoneVerify.hidden = true;
            }
            else if (state == "authorizationStateWaitEmailAddress")
            {

            }
            else if (state == "authorizationStateWaitCode") // waiting for auth code
            {
                DOMcodeVerify.hidden = false;
                while (true)
                {
                    await waitListener(DOMcodeButton, "click");
                    let result = undefined;
                    try
                    {
                        result = await sendGlobal({
                            '@type': 'checkAuthenticationCode',
                            code: DOMcodeNumber.value,
                        });
                    }
                    catch
                    {
                        DOMcodeVerifyError.innerText = "Invalid Code. Check telegram for it."
                    }
                    DOMcodeNumber.value = "";
                    if (result && result["@type"] == 'ok')
                    {
                        break;
                    }
                }
                DOMcodeVerify.hidden = true;
            }
            else if (state == "authorizationStateWaitRegistration")
            {

            }
            else if (state == "authorizationStateWaitPassword")
            {
                DOMpasswordVerify.hidden = false;
                while (true)
                {
                    await waitListener(DOMpasswordButton, "click");

                    let result = undefined;
                    try
                    {
                        result = await sendGlobal({
                            '@type': 'checkAuthenticationPassword',
                            password: DOMpasswordNumber.value,
                        });
                    }
                    catch
                    {
                        DOMpasswordVerifyError.innerText = "Invalid Password. D: Try again?"
                    }
                    DOMpasswordNumber.value = "";
                    if (result && result["@type"] == 'ok')
                    {
                        break;
                    }

                }
                // TODO
                DOMpasswordVerify.hidden = true;
            }
            else if (state == "authorizationStateReady")
            {
                DOMlogin.hidden = true;
                getChats();

                // hoist
                user = await sendGlobal({
                    "@type": "getMe",
                });
                DOMlogUserID.textContent = "user_id: " + user.id;
            }
        }
        else if (type == "updateNewChat")
        {
            if (!bAuthDone)
            {
                bAuthDone = true;
                authorizationDone();
            }
            if (data.chat.type["@type"] == "chatTypeSupergroup" && data.chat.type.is_channel)
            {
                //if (data.chat.title != "Torvid Content")
                //    return;

                //if (data.chat.title.includes("Poss"))
                //    return;

                let supergroup = await sendGlobal({
                    '@type': 'getSupergroup',
                    supergroup_id: data.chat.type.supergroup_id,
                });

                let supergroupInfo = await sendGlobal({
                    "@type": "getSupergroupFullInfo",
                    supergroup_id: supergroup.id,
                });

                loadCount++;
                // If you are a member
                if (supergroup.status["@type"] === 'chatMemberStatusMember' ||
                    supergroup.status["@type"] === 'chatMemberStatusCreator' ||
                    supergroup.status["@type"] === 'chatMemberStatusAdministrator' ||
                    supergroup.status["@type"] === 'chatMemberStatusRestricted')
                {
                    // If it has a username, IE it's public
                    // TODO: remove this limitation
                    if (supergroup.username)
                    {
                        channels[data.chat.id] = {};
                        channels[data.chat.id].title = data.chat.title
                        channels[data.chat.id].chat = data.chat;
                        channels[data.chat.id].supergroup = supergroup;
                        channels[data.chat.id].supergroupInfo = supergroupInfo;
                        channels[data.chat.id].zeroCount = 0
                        channels[data.chat.id].bIsDiscussion = false;
                        channels[data.chat.id].discussionChannel = null;

                        if (supergroup.has_linked_chat)
                        {
                            let discussionChat = await sendGlobal({
                                '@type': 'getChat',
                                chat_id: supergroupInfo.linked_chat_id,
                            });
                            let discussionSupergroup = await sendGlobal({
                                '@type': 'getSupergroup',
                                supergroup_id: discussionChat.type.supergroup_id,
                            });
                            let discussionSupergroupInfo = await sendGlobal({
                                "@type": "getSupergroupFullInfo",
                                supergroup_id: discussionSupergroup.id,
                            });
                            channels[discussionChat.id] = {};
                            channels[discussionChat.id].title = discussionChat.title
                            channels[discussionChat.id].chat = discussionChat;
                            channels[discussionChat.id].supergroup = discussionSupergroup;
                            channels[discussionChat.id].supergroupInfo = discussionSupergroupInfo;
                            channels[discussionChat.id].zeroCount = 0
                            channels[discussionChat.id].bIsDiscussion = true;
                            channels[discussionChat.id].discussionChannel = null;
                            channels[discussionChat.id].discussionChannel = channels[discussionChat.id];
                            channels[data.chat.id].discussionChannel = channels[discussionChat.id];
                        }
                    }
                }

                if (supergroup.status["@type"] === 'chatMemberStatusCreator')
                {
                    // the "timeline" channel description ends with your user ID, so it can be found here.
                    // mmmm yes sneaking in metadata my beloved.

                    if (supergroupInfo.description.endsWith(user.id))
                    {
                        timelineChannel = data.chat
                    }
                }
            }
        }
    }

    let bAuthDone = false;
    // Called when auth is completed.
    function authorizationDone()
    {
    }
    let options =
    {
        logVerbosityLevel: 1,
        jsLogVerbosityLevel: 3,
        mode: 'wasm',
        prefix: 'tdlib',
        readOnly: false,
        isBackground: false,
        useDatabase: true,
        wasmUrl: `3dee0f934ca1a5946a253599e3e442c6.wasm`,
        onUpdate: update
    };

    let client = new tdweb.default(options)
</script>