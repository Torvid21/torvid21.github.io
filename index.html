<!DOCTYPE html>
<script>
    // Welcome to my single-file webapp, Telegram Timeline!
    // Written by Torivd and ChatGPT.
    // I'm not a web developer by trade. Hopefully I didn't fuck up any security stuff. :)

    // TODO:
    // Add tooltips to everything
    // Add suppor tfor Posting messages to a custom channel
    // viewing a single channel
        // Loading channel description, etc
    // "share" button that works
    // Add meta-tags with some nice marketing images

    // Lightbox forimages
    // Arbitrary file download?
    // Download button for files

    // TODO: add DMs in the bottom right

    // TODO: add a list of everyone you currently follow
    //  Maybe have it ask your interests? (memes, furry, cars, food/cooking, etc)

    // TODO: make it so posts are cleverly filtered such that channels that spam a lot show up less

    // TODO: add support for looking at a single message

    // TODO: make the UI niced, show description, etc

    // TODO: add support for commenting inline, comment threading

    // TODO: support for likes

    // TODO: loading replies as sub-threads

    // TODO: make it load the minithumbnail at the right size immedietly
</script>
What?

This is Telegram Timeline. It takes all the Channels (not groups or DMs) that you are a member of on Telegram, and puts them all into a singular feed, Just like twitter.

<!--
teletime.net

    Now that twitter has no discoverability anymore, we could just move to telegram. :)
    This telegram client takes all the channels you follow and puts them into a single feed.
    Tell me what you think, Poke @Torvid with thoughts and ideas. Especially if you are an experienced web developer <3.

    The whole website is a single ~2kLOC html file containing all the html/css/script, so it should be easy for anyone to audit.
    Only external library is TDweb, a wrapper for the telegram API found here:
    https://www.npmjs.com/package/tdweb

    LIVE version is here: https://teletime.net/
    DEV version is here: http://212.100.102.124:8000/

Let's turn telegram into twitter
Want to escape twitter?
Already use telegram?

This web client takes all the telegram channels you follow and puts them into a single feed.

You can comment, like and retweet (forward) just like on twitter!

:)

[login thingy]

For the techy people,
This is app written in pure JS using TDweb, and is hosted statically on github.io here: [link]

something something preocupied with whether they could

-->

<style>
    /*css to make it look like some terrible amalgum of telegram and twitter.*/
    :root {
        --background: #0E1621;
        --message: #182533;
        --message-hover: #23364a;
        --button-hover: #40678b;
        --user-text: #ffffff;
    }

    body {
        background-color: var(--background);
        color: #FFFFFF;
        font-family: 'Atkinson Hyperlegible', sans-serif; /*I like this font, open to changes though.*/
        font-style: normal;
    }

    /* needed for the hidden attribute to actually work lol */
    [hidden] {
        display: none !important;
    }

    message {
        background-color: var(--message);
        display: block;
        margin: 1em;
        border-radius: 1em;
        width: 37em;
        padding: 0.5em;
        height: 50%;
        transition: background-color 0.1s;
    }
        message.comment {
            margin-left: 5em;
            width: 33em;
        }

    message-caption {
        display: block;
        padding: 0.5em;
        white-space: break-spaces;
    }

    message:hover {
        background-color: var(--message-hover);
        cursor: pointer;
    }
    message message-profile img {
        width: 4em;
        height: 4em;
        border-radius: 4em;
    }

    message message-profile span {
        position: relative;
        top: -3.0em;
        left: 0.5em;
        padding: 0.5em;
        color: #72BAFA;
        font-weight: Bold;
    }

    message-profile {
        display: block;
        width: fit-content;
    }
    message-profile span:hover {
        text-decoration: underline;
    }

    message-content {
        left: 4.5em;
        top: -3em;
        position: relative;
        max-width: 29em;
        width: fit-content;
        display: block;
    }

    message-timestamp {
        text-align: right;
        display: block;
        padding: 0.5em;
        font-size: small;
        color: #71767B;
    }

    message-interactions {
        /* margin: 2em; */
        position: relative;
        top: -2em;
        left: 1em;
        white-space: nowrap;
        display: block;
    }

    message-images {
        margin-right: 6em;
        display: grid;
        grid-template-columns: repeat(2, 1fr);
    }

        message-images img {
            margin: 0.1em;
            border-radius: 1em;
            width: 100%;
        }

        message-images video {
            border-radius: 1em;
            width: 100%;
        }

        message-images progress {
            width: 100%;
            display: block;
        }

        message-images img:nth-child(1) {
            grid-column: 1 / 3;
        }

        message-images video:nth-child(1) {
            grid-column: 1 / 3;
        }

    button {
        background-color: #FFFFFF00;
        border: none;
        color: white;
        width: 7.5em;
        /* height: 0em; */
        position: relative;
        display: inline;
        cursor: pointer;
    }

        button span {
            position: absolute;
            top: 0.8em;
            left: 6.5em;
        }

        button:hover::before {
            background-color: var(--button-hover);
        }

        .hovercircle::before {
            content: "";
            background-size: 2.5em 2.5em;
            background-repeat: no-repeat;
            background-position: center;
            width: 2.5em;
            height: 2.5em;
            position: absolute;
            transition: background-color 0.1s;
            border-radius: 2em;
        }

        button::after {
            content: "";
            background-image: url('icon-reply.png');
            background-size: 1.2em 1.2em;
            background-repeat: no-repeat;
            background-position: center;
            width: 2.5em;
            height: 2.5em;
            position: absolute;
        }

    .reply::after {
        background-image: url('icon-reply.png');
    }

    .retweet::after {
        background-image: url('icon-retweet.png');
    }

    .like::after {
        background-image: url('icon-like.png');
    }

    .views::after {
        background-image: url('icon-views.png');
    }

    .share::after {
        background-image: url('icon-share.png');
    }

    .disabled {
        filter: sepia(100%) saturate(0%) brightness(50%);
    }

    .messageInput, .replyInput {
        display: flex;
        flex-direction: row;
        align-items: flex-start; /* Aligns the items vertically */
        gap: 0.2em; /* Optional: Adds space between the textarea and the button */
    }
    #messageTextbox, #replyTextbox {
        width: 38em;
        min-height: 4em; /* Adjust the height as needed */
        resize: vertical; /* Allows vertical resizing of the textarea */
        border: 0px solid #ccc;
        font-family: 'Atkinson Hyperlegible', sans-serif;
        /* font-style: normal; */
        font-size: 1em;
        /* box-sizing: border-box; */
        border-radius: 0.5em;
        padding-left: 0.5em;
        color: white;
        background-color: #355779;
        resize: none;
        outline: none;
    }
    #messageSendButton, #replySendButton {
        width: 5em;
        height: 5em;
        background-color: #355779;
        color: white;
        border-width: 0;
        border-radius: 0.5em;
    }


    /*taken from w3schools*/
    .loader {
        border: 8px solid #182533;
        border-radius: 50%;
        border-top: 8px solid #3498db;
        width: 3em;
        height: 3em;
        /* -webkit-animation: spin 2s linear infinite; */ /* Safari */
        animation: spin 2s linear infinite;
    }
    /* Safari */
    @-webkit-keyframes spin {
        0% {
            -webkit-transform: rotate(0deg);
        }
        100% {
            -webkit-transform: rotate(360deg);
        }
    }
    @keyframes spin {
        0% {
            transform: rotate(0deg);
        }
        100% {
            transform: rotate(360deg);
        }
    }

</style>

<head>
    <!--<meta http-equiv="refresh" content="0; url=https://torvid21.github.io/index.html">-->
</head>

<body>

    <a href="/"><h1>Telegram Timeline</h1></a>

    <div style="white-space: break-spaces;">
        <!--This is going to be crazy.
        Very in-development, feel free to poke @Torvid if you find bugs!-->
        idk why I created this.
        Twitter except secretly it's telegram
    </div>

    <div id="status" hidden>
        <p id="state">state: </p>
        <p id="auth_state">auth_state: </p>
        <p id="user_id">user_id: </p>
    </div>


    <div id="phoneVerify">
        <label for="phone">Enter phone number:</label>
        <input type="tel" id="phoneNumber" name="phone">
        <input type="button" id="phoneButton" value="ok">
        <div id="phoneVerifyError"></div>
        <br />
        You need to use the regional indicator (+46xxxx...)
    </div>

    <div id="codeVerify">
        <label for="phone">Login code sent to your telegram account! Enter it here:</label><br />
        <input type="tel" id="codeNumber" name="phone">
        <input type="button" id="codeButton" value="ok">
        <div id="codeVerifyError"></div>
    </div>

    <div id="passwordVerify">
        <label for="phone">Two-factor auth is enabled, Enter your telegram password:</label><br />
        <input type="password" id="passwordNumber" name="phone">
        <input type="button" id="passwordButton" value="ok">
        <div id="passwordVerifyError"></div>
    </div>

    <div id="mainView">

        <div id="Home">
            <h1>Home</h1>

            <span>What's happening?</span>
            <br />
            <div class="messageInput" , id="messageInput">
                <textarea id="messageTextbox"></textarea>
                <input type="button" id="messageSendButton" value="Send">
            </div>

            <div class="messageInput" id="replyInput" hidden>
                <textarea id="replyTextbox"></textarea>
                <input type="button" id="replySendButton" value="Send">
            </div>
        </div>

        <div id="Channel">
            <h1>Channel</h1>
        </div>

        <div id="Thread">
            <h1>Thread</h1>
        </div>

        <p id="channelList">
        </p>

    </div>

    <center>
        <div id="loader" class="loader"></div>
    </center>
</body>

<!-- Telegram library-->
<script src="tdweb.js"></script>

<script>
    'use strict'; // first we use strict, because hoisting is unbased

    // then some utility functions
    // from here - https://www.npmjs.com/package/last-seen-ago?activeTab=readme
    function getNiceTime(date)
    {
        var currentTime = Math.floor(Date.now() / 1000) // timestamp in seconds
        var differenceTime = currentTime - Math.floor(date / 1000);
        var seconds = differenceTime;
        var minutes = Math.floor(seconds / 60);
        var hours = Math.floor(seconds / 3600);
        var days = Math.floor(seconds / 86400);
        var weeks = Math.floor(seconds / 604800);
        var months = Math.floor(seconds / 2629440);
        var years = Math.floor(seconds / 31553280);

        if (seconds <= 60)
        {
            return "Just Now";
        }
        else if (minutes <= 60)
        {
            if (minutes == 1) return "one minute ago";
            else return `${minutes} minutes ago`;
        }
        else if (hours <= 24)
        {
            if (hours == 1) return "an hour ago";
            else return `${hours} hrs ago`;
        }
        else if (days <= 7)
        {
            if (days == 1) return "yesterday";
            else return `${days} days ago`;
        }
        else if (weeks <= 4.3)
        {
            if (weeks == 1) return "a week ago";
            else return `${weeks} weeks ago`;
        }
        else if (months <= 12)
        {
            if (months == 1) return "a month ago";
            else return `${months} months ago`;
        }
        else
        {
            if (years == 1) return "one year ago";
            else return `${years} years ago`;
        }
    }

    // copied from stackoverflow, "wait for input"
    // https://stackoverflow.com/questions/51374649/using-async-functions-to-await-user-input-from-onclick
    function waitListener(element, listenerName)
    {
        return new Promise(function (resolve, reject)
        {
            var listener = event =>
            {
                element.removeEventListener(listenerName, listener);
                resolve(event);
            };
            element.addEventListener(listenerName, listener);
        });
    }

    // some global variables :)
    var loadedMessages = [] // groups messages into albums
    var allMessages = [] // does not group messages into albums
    var channels = {}
    var user = undefined; // current user
    var timelineChannel = undefined // your timeline channel

    var status_waitPhoneNumber = "waitPhoneNumber" // wating for phone number
    var status_waitCode = "waitCode" // waiting for code auth
    var status_home = "home" // home, viewing your feed of all messages
    var status_channel = "channel" // viewing a single channel/user
    var status_thread = "thread" // viewing a single message
    var current_status = status_waitPhoneNumber


    const urlParams = new URLSearchParams(window.location.search);
    var channel_name_or_id = urlParams.get("channel");
    var channel_message_id = urlParams.get("message");


    // nukes all loaded messages
    async function reset()
    {
        DOMchannelList.innerHTML = "";
        loadedMessages = [];
        allMessages = [];
        //window.location.href = "?&channel=magpistreams";
        //window.location.href = "?&private_channel_id=343245532";
    }


    // get html elements
    var DOMlogState = document.getElementById("state");
    var DOMlogStateAuth = document.getElementById("auth_state");
    var DOMlogUserID = document.getElementById("user_id");

    var DOMphoneVerify = document.getElementById("phoneVerify");
    var DOMphoneVerifyError = document.getElementById("phoneVerifyError");
    var DOMphoneButton = document.getElementById("phoneButton");
    var DOMphoneNumber = document.getElementById("phoneNumber");
    DOMphoneVerify.hidden = true;

    var DOMcodeVerify = document.getElementById("codeVerify");
    var DOMcodeVerifyError = document.getElementById("codeVerifyError");
    var DOMcodeButton = document.getElementById("codeButton");
    var DOMcodeNumber = document.getElementById("codeNumber");
    DOMcodeVerify.hidden = true;
    
    var DOMpasswordVerify = document.getElementById("passwordVerify");
    var DOMpasswordVerifyError = document.getElementById("passwordVerifyError");
    var DOMpasswordButton = document.getElementById("passwordButton");
    var DOMpasswordNumber = document.getElementById("passwordNumber");
    DOMpasswordVerify.hidden = true;

    var DOMmainView = document.getElementById("mainView");
    var DOMtestButton = document.getElementById("testButton");
    var DOMchannelList = document.getElementById("channelList");

    var DOMmessageInput = document.getElementById("messageInput");
    var DOMmessageSendButton = document.getElementById("messageSendButton");
    var DOMmessageTextbox = document.getElementById("messageTextbox");

    var DOMreplyInput = document.getElementById("replyInput");
    var DOMreplySendButton = document.getElementById("replySendButton");
    var DOMreplyTextbox = document.getElementById("replyTextbox");

    var DOMhome = document.getElementById("Home");
    var DOMchannel = document.getElementById("Channel");
    var DOMthread = document.getElementById("Thread");

    var DOMloader = document.getElementById("loader");

    DOMmainView.hidden = true;

    DOMmessageSendButton.addEventListener("click", function ()
    {
        if (DOMmessageTextbox.value == "")
            return;
        sendMessage(DOMmessageTextbox.value, timelineChannel.id);
        DOMmessageTextbox.value = "";
    });
    DOMmessageTextbox.addEventListener("keydown", function (event)
    {
        if (event.shiftKey)
            return;
        if (event.ctrlKey)
            return;
        if (event.key === "Enter")
        {
            event.preventDefault();

            if (DOMmessageTextbox.value == "")
                return;
            sendMessage(DOMmessageTextbox.value, timelineChannel.id);
            DOMmessageTextbox.value = "";
        }
    });

    var global_chat_id = 0;
    var global_reply_id = 0;
    var global_message_thread_id = 0;
    DOMreplySendButton.addEventListener("click", function ()
    {
        if (DOMreplyTextbox.value == "")
            return;
        DOMreplyInput.hidden = true;
        sendMessage(DOMreplyTextbox.value, global_chat_id, global_reply_id, global_message_thread_id);
        DOMreplyTextbox.value = "";
    });
    DOMreplyTextbox.addEventListener("keydown", function (event)
    {
        if (event.shiftKey)
            return;
        if (event.ctrlKey)
            return;
        if (event.key === "Enter")
        {
            event.preventDefault();

            if (DOMreplyTextbox.value == "")
                return;
            DOMreplyInput.hidden = true;
            sendMessage(DOMreplyTextbox.value, global_chat_id, global_reply_id, global_message_thread_id);
            DOMreplyTextbox.value = "";
        }
    });

    async function sendMessage(contents, chat_id, reply_to_message_id = 0, message_thread_id = 0)
    {
        // Send a text message to the channel
        const result = await client.send({
            "@type": "sendMessage",
            chat_id: chat_id,
            reply_to_message_id: reply_to_message_id,
            message_thread_id: message_thread_id,
            input_message_content: {
                "@type": "inputMessageText",
                text: {
                    "@type": "formattedText",
                    text: contents,
                },
                disable_web_page_preview: false,
                clear_draft: true,
            },
        });

        console.log(result)
        //window.location.reload(); // TODO: fix
        //addMessage(result, timelineChannel, false);
    }


    var scrollChecker = setInterval(function ()
    {
        scroll = document.body.offsetHeight - (window.innerHeight + Math.ceil(window.pageYOffset));
        if (scroll < 500)
        {
            loadMore();
        }
    }, 250);

    async function setProfilePicEventually(img, photo)
    {
        if (!photo)
        {
            img.src = "missing-picture.png"
            return;
        }

        // 1. immedietly set it to the mini pic
        img.src = "data:image/jpeg;base64," + photo.minithumbnail.data;

        // 2. slowly download the full pic and set it.
        img.src = await loadImage(photo.small);
    }

    // Creates a message and appends it to the DOM
    async function createMessage(id, chat, message, use_hiding = true, bIsComment = false)
    {
        // Create and append the message tag to the DOM immedietly
        var firstChildThatIsOlderThanNewMessage = undefined
        for (const child of DOMchannelList.children)
        {
            if (date > child.getAttribute("timestamp"))
            {
                firstChildThatIsOlderThanNewMessage = child
                break;
            }
        }
        var DOMmessage = document.createElement("message");

       
        if (!bIsComment)
        {
            //if (firstChildThatIsOlderThanNewMessage)
            //    DOMchannelList.insertBefore(DOMmessage, firstChildThatIsOlderThanNewMessage.nextSibling);
            //else
            DOMchannelList.appendChild(DOMmessage);
        }

        var date = message.date;

        var forwardcount = 0
        var viewcount = 0
        if (message.interaction_info)
        {
            message.interaction_info.forward_count;
            message.interaction_info.view_count;
        }

        var bCommentsEnabled = channels[chat.id].supergroup.has_linked_chat;

        var retweet_message = undefined
        var title = undefined;
        var profile_pic = undefined;
        var username = undefined;

        if (message.forward_info) // if it was forwarded
        {
            // forwarded from a user
            if (message.forward_info.origin["@type"] == "messageForwardOriginUser")
            {
                var user = await client.send({
                    "@type": "getUser",
                    "user_id": message.forward_info.origin.sender_user_id,
                });
                username = user.username;
                profile_pic = user.profile_photo;//await loadImage(user.profile_photo.small);
            }
            else if (message.forward_info.origin["@type"] == "messageForwardOriginChannel")
            {
                var channel = channels[message.forward_info.origin.chat_id];
                if (channel)
                {
                    profile_pic = channel.chat.photo;
                    title = channel.chat.title
                    username = channel.supergroup.username
                    if (!username)
                        username = channel.chat.id
                }
            }

            retweet_message = chat.title;
        }
        else
        {
            if (bIsComment)
            {
                if (message.sender_id["@type"] == "messageSenderUser")
                {
                    var user = await client.send({
                        "@type": "getUser",
                        "user_id": message.sender_id.user_id,
                    });

                    if (user.profile_photo)
                        profile_pic = user.profile_photo;
                    title = user.first_name;
                    username = user.username;
                }
                else if (message.sender_id["@type"] == "messageSenderChat")
                {
                    profile_pic = chat.photo;
                    title = chat.title
                    const channelSupergroup = await client.send({
                        '@type': 'getSupergroup',
                        supergroup_id: chat.type.supergroup_id,
                    });
                    username = channelSupergroup.username
                    if (!username)
                        username = channel.chat.id
                }
            }
            else
            {
                if (channels[chat.id].chat.photo)
                    profile_pic = channels[chat.id].chat.photo;
                title = chat.title;
                username = channels[chat.id].supergroup.username
                if (!username)
                    username = chat.id
            }
        }

        loadedMessages[id] = {};
        if (loadedMessages[id].messages == undefined)
            loadedMessages[id].messages = []
        loadedMessages[id].messages.push(message);

        if (channels[chat.id].latestDOMmessage)
        {
            DOMloader.hidden = true;
            channels[chat.id].latestDOMmessage.hidden = false;
            channels[chat.id].latestDOMmessage.parentNode.appendChild(channels[chat.id].latestDOMmessage); // move it to the bottom
        }
        // do this after rearranging so the comments always show up last
        if (bIsComment)
        {
            DOMmessage.setAttribute("class", "comment");
            DOMchannelList.appendChild(DOMmessage);
        }

        if (!bCommentsEnabled)
            DOMloader.hidden = true;

        if(use_hiding)
            DOMmessage.hidden = true;

        channels[chat.id].latestDOMmessage = DOMmessage;
        loadedMessages[id].DOMmessage = DOMmessage;

        DOMmessage.setAttribute("timestamp", date)
        if (retweet_message)
        {
            loadedMessages[id].DOMretweeted_by = loadedMessages[id].DOMmessage.appendChild(document.createElement("message-retweet"));
            loadedMessages[id].DOMmessage.textContent = chat.title + " retweeted"
        }

        var DOMprofile              = DOMmessage.appendChild(document.createElement("message-profile"));
        var DOMprofileImg           = DOMprofile.appendChild(document.createElement("img"));
        var DOMprofileUsername      = DOMprofile.appendChild(document.createElement("span"));
        loadedMessages[id].DOMprofile           = DOMprofile;
        loadedMessages[id].DOMprofileImg        = DOMprofileImg;
        loadedMessages[id].DOMprofileUsername   = DOMprofileUsername;

        var DOMcontent       = DOMmessage.appendChild(document.createElement("message-content"));
        var DOMcaption       = DOMcontent.appendChild(document.createElement("message-caption"));
        var DOMimages        = DOMcontent.appendChild(document.createElement("message-images"));
        var DOMinteractions  = DOMmessage.appendChild(document.createElement("message-interactions"));
        loadedMessages[id].DOMcontent       = DOMcontent;
        loadedMessages[id].DOMcaption       = DOMcaption;
        loadedMessages[id].DOMimages        = DOMimages;
        loadedMessages[id].DOMinteractions  = DOMinteractions;

        DOMmessage.addEventListener("click", async function (event)
        {
            var bHitMessage = false;
            var bHitProfile = false;
            if (event.target == DOMmessage)
                bHitMessage = true;
            if (event.target == DOMcontent)
                bHitMessage = true;
            if (event.target == DOMimages)
                bHitMessage = true;
            if (event.target == DOMprofile)
                bHitMessage = true;

            if (event.target == DOMprofileImg)
                bHitProfile = true;
            if (event.target == DOMprofileUsername)
                bHitProfile = true;

            if (bHitMessage) // go to message / comments
            {
                window.location.href = "?channel=" + username + "&message=" + message.id;
            }
            else if (bHitProfile) // go to profile
            {
                window.location.href = "?channel="+username;
            }
        });

        var messageThread = null;
        try
        {
            messageThread = await client.send({
                '@type': 'getMessageThread',
                chat_id: chat.id,
                message_id: message.id,
            });
        }
        catch (err)
        {
            console.log(err)
        }
        console.log(messageThread);
        loadedMessages[id].DOMreply = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        if (bCommentsEnabled)
        {
            loadedMessages[id].DOMreply.setAttribute("class", "reply hovercircle");
            loadedMessages[id].DOMreply.addEventListener("click", function (_DOMmessage, chat, message, thread)
            {
                channel = channels[chat.id];

                return async function ()
                {
                    if (thread)
                    {
                        global_chat_id = thread.chat_id;
                        global_reply_id = thread.messages[0].id;
                        global_message_thread_id = thread.message_thread_id;
                    }
                    else
                    {
                        global_chat_id = message.chat_id;
                        global_reply_id = message.id;
                        global_message_thread_id = message.message_thread_id;
                    }
                    DOMreplyInput.hidden = false;
                    _DOMmessage.appendChild(DOMreplyInput);
                }
            }(DOMmessage, chat, message, messageThread))
        }
        else
        {
            loadedMessages[id].DOMreply.setAttribute("class", "reply disabled");
        }
        loadedMessages[id].DOMreplyText = loadedMessages[id].DOMreply.appendChild(document.createElement("span"))
        loadedMessages[id].DOMreplyText.textContent = 0;

        loadedMessages[id].DOMretweet = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        loadedMessages[id].DOMretweet.setAttribute("class", "retweet hovercircle");
        loadedMessages[id].DOMretweet.appendChild(document.createElement("span")).textContent = forwardcount;
        
        loadedMessages[id].DOMretweet.addEventListener("click", function (inner_id, inner_chatId)
        {
            return async function ()
            {
                var fwd = loadedMessages[inner_id].messages;
                var msgs = [];
                for (var i = 0; i < fwd.length; i++)
                {
                    msgs.push(fwd[i].id)
                }
                client.send({
                    '@type': 'forwardMessages',
                    from_chat_id: inner_chatId,
                    chat_id: timelineChannel.id,
                    message_ids: msgs,
                });
            }
        }(id, chat.id));
        
        loadedMessages[id].DOMlike = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        loadedMessages[id].DOMlike.setAttribute("class", "like hovercircle");
        loadedMessages[id].DOMlike.appendChild(document.createElement("span")).textContent = 0;

        var DOMviews = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        DOMviews.setAttribute("class", "views hovercircle");
        DOMviews.appendChild(document.createElement("span")).textContent = viewcount;

        var DOMshare = loadedMessages[id].DOMinteractions.appendChild(document.createElement("button"));
        DOMshare.setAttribute("class", "share hovercircle");
        DOMshare.appendChild(document.createElement("span")).textContent = ""

        loadedMessages[id].DOMtimestamp = DOMmessage.appendChild(document.createElement("message-timestamp"));

        // async function that sets the picture later when it feels like it. :)
        setProfilePicEventually(loadedMessages[id].DOMprofileImg, profile_pic)

        loadedMessages[id].DOMprofileUsername.textContent = title
        loadedMessages[id].DOMtimestamp.textContent = getNiceTime(new Date(date * 1000));
    }

    async function loadMore()
    {
        if (!doneLoading)
            return;

        if (current_status == status_thread) // If in this state, we should read comments instead.
            return;

        //for (var j = 0; j < 5; j++)
        {
            var smallest = undefined;
            var smallestTimestamp = 0;
            var smallestID = 0;
            // find the channel with the most recent message and load that one
            for (var i = 0; i < Object.keys(channels).length; i++)
            {
                var channel = channels[Object.keys(channels)[i]];
                if (channel.exhausted)
                    continue;

                var timestamp = channel.latestMessageTimestamp
                if (timestamp > smallestTimestamp)
                {
                    smallestTimestamp = timestamp
                    smallest = channel;
                    smallestID = Object.keys(channels)[i];
                }
            }
            if (smallest)
                loadMessageFromChannel(smallest.chat)
        }
    }

    var imageCache = {};

    async function loadImage(file)
    {
        return loadFile(file, "image/png", null);
        ////return loadFile(file, "image/png", null);
        //if (!imageCache.hasOwnProperty(file.id))
        //{
        //    imageCache[file.id] = loadFile(file, "image/png", null);
        //}
        //return imageCache[file.id];
    }
    async function loadFile(file, mime_type, setProgress)
    {
        if (!imageCache.hasOwnProperty(file.id))
        {
            const blob = await loadFileBlob(file, mime_type, setProgress)
            imageCache[file.id] = URL.createObjectURL(blob);
        }
        return imageCache[file.id];

        //const blob = await loadFileBlob(file, mime_type, setProgress)
        //return URL.createObjectURL(blob);
    }
    async function loadFileBlob(file, mime_type, setProgress)
    {
        // TODO: add support for streaming large video files.

        const CHUNK_SIZE = 1024 * 64; // 64KB

        let offset = 0;
        let fileSize = file.size;

        const chunks = [];
        while (true)
        {
            var DLSize = Math.min(CHUNK_SIZE, fileSize - offset)

            if (fileSize == 0) // unknown filesize, just start downloading it
                DLSize = CHUNK_SIZE;

            if (DLSize <= 0)
                break;

            if (!file.is_downloading_completed)
            {
                var result = await client.send({
                    '@type': 'downloadFile',
                    file_id: file.id,
                    priority: 1,
                    offset: offset, // where in the file to start downloading
                    limit: DLSize, // how much to download in bytes
                    synchronous: true, // download the file synchronously
                });
                fileSize = result.size;
            }

            const result2 = await client.send({
                '@type': 'readFilePart',
                file_id: file.id,
                offset: offset,
                count: Math.min(CHUNK_SIZE, fileSize - offset),
            });

            const fileData = result2.data;
            chunks.push(fileData);

            if (setProgress)
                setProgress(offset, fileSize);

            offset += CHUNK_SIZE;
        }
        const blob = new Blob(chunks, { type: mime_type });
        if (setProgress)
            setProgress(fileSize, fileSize);

        return blob;
    }

    async function setReplyCount(id, message)
    {
        if (loadedMessages[id].DOMreplyText.textContent == 0 && message.interaction_info && message.interaction_info.reply_info)
            loadedMessages[id].DOMreplyText.textContent = message.interaction_info.reply_info.reply_count;
    }
    async function addImage(id, message, image)
    {
        var images = loadedMessages[id].DOMimages;

        var img = document.createElement('img');

        images.prepend(img);

        loadImage(image).then((src) =>
        {
            img.src = src;
        })
        return img;
    }
    async function addVideo(id, message, video, thumbnail, controls)
    {
        var thumbnailPath = await loadImage(thumbnail);
        var DOMvideo = document.createElement('video');
        var images = loadedMessages[id].DOMimages;
        images.prepend(DOMvideo);

        if (controls)
        {
            DOMvideo.setAttribute("controls", "");
        }
        else
        {
            DOMvideo.setAttribute("autoplay", "");
            DOMvideo.setAttribute("loop", "");
        }

        DOMvideo.setAttribute("poster", thumbnailPath);

        var progress = images.appendChild(document.createElement('progress'));
        var videoUrl = await loadFile(video, "video/mp4", function (value, max)
        {
            if (value == max) // done
            {
                progress.hidden = true;
            }
            progress.setAttribute("value", value)
            progress.setAttribute("max", max)
        });

        var source = document.createElement('source');
        source.setAttribute("src", videoUrl);
        DOMvideo.appendChild(source);
    }
    async function setCaption(id, message, caption)
    {
        if (loadedMessages[id].DOMcaption.textContent == "")
            loadedMessages[id].DOMcaption.textContent = caption;
    }
    function isMessageSupported(message)
    {
        if (message.id in allMessages) // we got the same message twice. reject it!
            return false;

        var contentType = message.content["@type"];
        if (contentType == "messageText")
            return true;
        else if (contentType == "messagePhoto")
            return true;
        else if (contentType == "messageVideo")
            return true;
        else if (contentType == "messageAnimation")
            return true;
        else if (contentType == "messageDocument")
            return true;
        else if (contentType == "messageSticker")
            return true;
        return false;
    }
    function getSupportedMessageCount(result)
    {
        var count = 0
        for (const message of result.messages)
        {
            if (isMessageSupported(message))
                count++;
        }
        return count;
    }


    // high level function to download and add a message to the timeline.
    async function addMessage(message, chat, use_hiding = true, bIsComment = false)
    {
        allMessages[message.id] = {};

        var id = message.media_album_id;
        if (message.media_album_id == 0)
            id = message.id;

        channels[chat.id].latestMessage = message.id;
        channels[chat.id].latestMessageTimestamp = message.date;

        var contentType = message.content["@type"];
        if (contentType == "messageText")
        {
            if (!(id in loadedMessages)) // new message
                await createMessage(id, chat, message, use_hiding, bIsComment);
            await setReplyCount(id, message);
            await setCaption(id, message, message.content.text.text);
        }
        else if (contentType == "messagePhoto")
        {
            if (!(id in loadedMessages)) // new message
                await createMessage(id, chat, message, use_hiding, bIsComment)
            await setReplyCount(id, message);
            await setCaption(id, message, message.content.caption.text);
            await addImage(id, message, message.content.photo.sizes[0].photo);
        }
        else if (contentType == "messageVideo")
        {
            if (!(id in loadedMessages)) // new message
                await createMessage(id, chat, message, use_hiding, bIsComment)
            await setReplyCount(id, message);
            await setCaption(id, message, message.content.caption.text);
            await addVideo(id, message, message.content.video.video, message.content.video.thumbnail.file, true)
        }
        else if (contentType == "messageAnimation")
        {
            if (!(id in loadedMessages)) // new message
                await createMessage(id, chat, message, use_hiding, bIsComment)
            await setReplyCount(id, message);
            await setCaption(id, message, message.content.caption.text);
            await addVideo(id, message, message.content.animation.animation, message.content.animation.thumbnail.file, false)
        }
        else if (contentType == "messageDocument")
        {
            if (!(id in loadedMessages)) // new message
                await createMessage(id, chat, message, use_hiding, bIsComment)
            await setReplyCount(id, message);
            await setCaption(id, message, message.content.caption.text);
            await addImage(id, message, message.content.document.thumbnail.file);
        }
        else if (contentType == "messageSticker")
        {
            if (!(id in loadedMessages)) // new message
                await createMessage(id, chat, message, use_hiding, bIsComment)
            await setReplyCount(id, message);
            await setCaption(id, message, "");
            var img = await addImage(id, message, message.content.sticker.thumbnail.file);

            // force stickers to be 256x256
            img.setAttribute("style", "width:256px")
        }
    }

    async function loadSingleMessage(chat, message_id)
    {
        var message = await client.send({
            '@type': 'getMessage',
            chat_id: chat.id,
            message_id: message_id,
        });

        await addMessage(message, chat, false);

        return message;
    }

    async function loadMessageFromChannel(chat)
    {
        var startID = channels[chat.id].latestMessage
        
        var messageCount = 1;

        var result = await client.send({
            '@type': 'getChatHistory',
            chat_id: chat.id,
            from_message_id: startID, // start from the latest message
            offset: 0, // no offset needed
            limit: messageCount, // number of messages to fetch
        });

        result = await client.send({
            '@type': 'getChatHistory',
            chat_id: chat.id,
            from_message_id: startID, // start from the latest message
            offset: 0, // no offset needed
            limit: messageCount, // number of messages to fetch
        });

        if (result['@type'] === 'messages')
        {
            // means we ran out of messages in the channel entirely?
            // and we should stop checking it for new messages.
            if (getSupportedMessageCount(result) == 0)
            {
                if (channels[chat.id].zeroCount > 3)
                {
                    channels[chat.id].exhausted = true;
                    console.log(channels[chat.id].chat);
                    console.log("^ CHANNEL EXHAUSTED ^. WAS THIS CORRECT?");
                }
                channels[chat.id].zeroCount++;
            }
            for (const message of result.messages)
            {
                channels[chat.id].zeroCount = 0;
                addMessage(message, chat);
            }
        }
    }

    // check 10 times per second (every 100ms)
    var doneLoading = false;
    var sameCount = 0;
    var lastChannelCount;
    var loadCount = 0;
    var startupDelayChecker = setInterval(function ()
    {
        if (current_status == status_channel || current_status == status_thread)
        {
            console.log("DONE LOADING!");
            clearInterval(startupDelayChecker);
            doneLoading = true;
            Startup();
            return;
        }

        if (loadCount == 0)
            return;

        if (lastChannelCount != loadCount)
        {
            lastChannelCount = loadCount;
            sameCount = 0;
        }
        else
        {
            sameCount++;
            // If we've held onto the same number of channels for 300ms, that means all the channels have probably been loaded and we can go ahead and start loading messages.
            if (sameCount >= 3)
            {
                console.log("DONE LOADING!");
                clearInterval(startupDelayChecker);
                doneLoading = true;
                Startup();
            }
        }
    }, 100);

    // Called once things are done loading.
    async function Startup()
    {
        DOMmainView.hidden = false;

        // If we want a single channel, but it was not found, search for it.
        if (current_status == status_channel || current_status == status_thread)
        {
            var chat = undefined
            try
            {
                console.log(`Trying to load channel ${channel_name_or_id} as chat ID`);
                chat = await client.send({
                    '@type': 'getChat',
                    chat_id: channel_name_or_id,
                });
            }
            catch (exceptionVar)
            {
                try
                {
                    console.log(`Trying to load channel ${channel_name_or_id} as public chat by Name`);
                    chat = await client.send({
                        '@type': 'searchPublicChat',
                        username: channel_name_or_id,
                    });
                }
                catch (exceptionVar)
                {
                    console.log(`Loading chat failed.`);
                }
            }

            if (chat)
            {
                const supergroup = await client.send({
                    '@type': 'getSupergroup',
                    supergroup_id: chat.type.supergroup_id,
                });

                const supergroupInfo = await client.send({
                    "@type": "getSupergroupFullInfo",
                    supergroup_id: supergroup.id,
                });

                channels[chat.id] = {};
                channels[chat.id].chat = chat;
                channels[chat.id].supergroup = supergroup;
                channels[chat.id].supergroupInfo = supergroupInfo;
                channels[chat.id].zeroCount = 0;

                // load one thing form every channel
                if (current_status == status_thread)
                {
                    // load the first message
                    var message = await client.send({
                        '@type': 'getMessage',
                        chat_id: chat.id,
                        message_id: channel_message_id,
                    });

                    // load comments
                    console.log("START getMessageThreadHistory");
                    const result = await client.send({
                        '@type': 'getMessageThreadHistory',
                        chat_id: chat.id,
                        message_id: message.id,
                        from_message_id: 0,
                        offset: 0,
                        limit: 10,
                    });
                    console.log("END getMessageThreadHistory");

                    if (result.messages[0])
                    {
                        // If a thread was found, to be able to reply to the main message
                        // we need to use the main message from the *thread*, not from the *channel*.
                        // we find the *thread* message by asking the first reply what it was replying to.
                        var discussionChat = await client.send({
                            '@type': 'getChat',
                            chat_id: result.messages[0].reply_in_chat_id,
                        });
                        console.log(discussionChat);
                        var message = await loadSingleMessage(discussionChat, result.messages[0].reply_to_message_id)

                        for (const message of result.messages)
                        {
                            addMessage(message, chat, false, true);
                        }
                    }
                    else
                    {
                        // if thread was empty, just load the one message directly.
                        var message = await loadSingleMessage(chat, channel_message_id)
                    }

                }
                else
                {
                    loadMessageFromChannel(chat);
                }
            }
            else
            {
                DOMchannelList.innerText = "Channel named " + channel_name_or_id + " could not be found."
            }
        }

        createTimelineChannel();
    }

    async function createTimelineChannel()
    {
        //// If we are viewing a single channel or message, we can't post to our own timeline.
        //if (bSingleChannel || bSingleMessage)
        //    return;
        //
        //// channel not found yet, create it!
        if (timelineChannel)
            return;

        // 1. Create the channel
        const chat = await client.send({
            "@type": "createNewSupergroupChat",
            title: user.username + "'s Telegram Timeline",
            is_channel: true,
            description: "This channel is your Timeline. \nMessages posted or retweeted on from teletime.net will show up here. \n\nThis last number is your user ID and needs to remain at the end of the description for Teletime to work correctly.\n" + user.id,
        });


        // 2. Enable replies by adding a "discussion group".
        const discssionGroup = await client.send({
            "@type": "createNewSupergroupChat",
            title: "Teletime - Discussion Group.",
            is_channel: false,
            description: "This is the discussion group for your telegram timeline. Feel free to ignore it.\n\n" + user.id + "DISCUSS",
        });
        await client.send({
            '@type': 'setChatDiscussionGroup',
            chat_id: chat.id,
            discussion_chat_id: discssionGroup.id,
        });


        // 3. Update the profile picture
        //const uniqueRemoteImageUrl = `$http://212.100.102.124:8000/Coal.png?${Date.now()}`;
        //console.log(uniqueRemoteImageUrl);
        //var setphotoresult = await client.send({
        //    "@type": "setChatPhoto",
        //    chat_id: chatId,
        //    photo: {
        //        "@type": "inputFileGenerated",
        //        original_path: uniqueRemoteImageUrl,
        //        conversion: "",
        //        expected_size: 0,
        //    },
        //});
        //await client.send({
        //    '@type': 'setChatPhoto',
        //    chat_id: chat.id,
        //    photo: {
        //        '@type': 'inputChatPhotoStatic',
        //        photo: {
        //            '@type': 'inputFileGenerated',
        //            original_path: uniqueRemoteImageUrl,
        //            conversion: '',
        //            expected_size: 0,
        //        },
        //    },
        //});

        // 4. Make it public.
        var public_username = user.username + "_Timeline";
        
        const isUsernameAvailable = await client.send({
            "@type": "checkChatUsername",
            chat_id: chat.id,
            username: public_username,
        });
        
        if (!isUsernameAvailable)
        {
            // TODO: handle this more gracefully. try again a bunch of times with alernate names?
            console.log("failed to make the channel public. PANIC.");
            return;
        }
        
        // don't wait for this, as it takes a while.
        client.send({
            "@type": "setSupergroupUsername",
            supergroup_id: chat.type.supergroup_id,
            username: public_username,
        });

        timelineChannel = chat;
    }

    async function getChats()
    {
        const result = await client.send({
            '@type': 'getChats',
            chat_list: {
                '@type': 'chatListMain',
            },
            limit: 20,
        });

        return await client.send({
            '@type': 'getChats',
            chat_list: {
                '@type': 'chatListMain',
            },
            limit: 20,
        });
    }

    async function update(data)
    {
        var type = data["@type"];
        DOMlogState.textContent = "state: " + type;

        if (type == "updateAuthorizationState")
        {
            var state = data.authorization_state["@type"];
            DOMlogStateAuth.textContent = "auth_state: " + state;

            if (state == "authorizationStateWaitTdlibParameters")
            {
                client.send({
                    '@type': 'setTdlibParameters',
                    parameters: {
                        '@type': 'tdlibParameters',
                        use_test_dc: false,
                        database_directory: 'tdlib',
                        files_directory: 'tdlib/files',
                        use_file_database: false,
                        use_chat_info_database: true,
                        use_message_database: true,
                        use_secret_chats: false,
                        api_id: 26827015,
                        api_hash: "66daa010ab01961d038809b996b791de",
                        system_language_code: 'en-GB',
                        device_model: 'Web',
                        system_version: 'Unknown',
                        application_version: '1.0',
                        enable_storage_optimizer: true,
                        ignore_file_names: false,
                    },
                });
            }
            else if (state == "authorizationStateWaitEncryptionKey")
            {
                client.send({
                    '@type': 'checkDatabaseEncryptionKey',
                    encryption_key: '', // no encryption
                });

                //client.send({'@type': 'checkDatabaseEncryptionKey', parameters:{client}});
                //await checkDatabaseEncryptionKey(client);
            }
            else if (state == "authorizationStateWaitPhoneNumber")
            {
                DOMphoneVerify.hidden = false;


                while (true)
                {
                    await waitListener(DOMphoneButton, "click");

                    var result = undefined;
                    try
                    {
                        result = await client.send({
                            '@type': 'setAuthenticationPhoneNumber',
                            phone_number: DOMphoneNumber.value.replace(/[^+\d]+/g, ""),
                            settings: {
                                '@type': 'phoneNumberAuthenticationSettings',
                                allow_flash_call: false,
                                is_current_phone_number: false,
                                allow_sms_retriever_api: false,
                            },
                        });
                    }
                    catch
                    {
                        DOMphoneVerifyError.innerText = "Invalid Phone Number. Make sure you use the country code."
                    }
                    DOMphoneNumber.value = "";
                    if (result && result["@type"] == 'ok')
                    {
                        break;
                    }
                }

                DOMphoneVerify.hidden = true;
            }
            else if (state == "authorizationStateWaitEmailAddress")
            {

            }
            else if (state == "authorizationStateWaitCode") // waiting for auth code
            {
                DOMcodeVerify.hidden = false;
                while (true)
                {
                    await waitListener(DOMcodeButton, "click");
                    var result = undefined;
                    try
                    {
                        result = await client.send({
                            '@type': 'checkAuthenticationCode',
                            code: DOMcodeNumber.value,
                        });
                    }
                    catch
                    {
                        DOMcodeVerifyError.innerText = "Invalid Code. Check telegram for it."
                    }
                    DOMcodeNumber.value = "";
                    if (result && result["@type"] == 'ok')
                    {
                        break;
                    }
                }
                DOMcodeVerify.hidden = true;
            }
            else if (state == "authorizationStateWaitRegistration")
            {

            }
            else if (state == "authorizationStateWaitPassword")
            {
                DOMpasswordVerify.hidden = false;
                while (true)
                {
                    await waitListener(DOMpasswordButton, "click");

                    var result = undefined;
                    try
                    {
                        result = await client.send({
                            '@type': 'checkAuthenticationPassword',
                            password: DOMpasswordNumber.value,
                        });
                    }
                    catch
                    {
                        DOMpasswordVerifyError.innerText = "Invalid Password. D: Try again?"
                    }
                    DOMpasswordNumber.value = "";
                    if (result && result["@type"] == 'ok')
                    {
                        break;
                    }

                }
                // TODO
                DOMpasswordVerify.hidden = true;
            }
            else if (state == "authorizationStateReady")
            {
                getChats();

                // hoist
                user = await client.send({
                    "@type": "getMe",
                });
                DOMlogUserID.textContent = "user_id: " + user.id;
            }
        }
        else if (type == "updateNewChat")
        {
            if (!bAuthDone)
            {
                bAuthDone = true;
                authorizationDone();
            }
            if (data.chat.type["@type"] == "chatTypeSupergroup" && data.chat.type.is_channel)
            {
                //if (data.chat.title != "Torvid Content")
                //    return;

                if (data.chat.title.includes("Poss"))
                    return;

                const supergroup = await client.send({
                    '@type': 'getSupergroup',
                    supergroup_id: data.chat.type.supergroup_id,
                });

                const supergroupInfo = await client.send({
                    "@type": "getSupergroupFullInfo",
                    supergroup_id: supergroup.id,
                });


                loadCount++;
                // If you are a member
                if (supergroup.status["@type"] === 'chatMemberStatusMember' ||
                    supergroup.status["@type"] === 'chatMemberStatusCreator' ||
                    supergroup.status["@type"] === 'chatMemberStatusAdministrator' ||
                    supergroup.status["@type"] === 'chatMemberStatusRestricted')
                {
                    channels[data.chat.id] = {};
                    channels[data.chat.id].title = data.chat.title
                    channels[data.chat.id].chat = data.chat;
                    channels[data.chat.id].supergroup = supergroup;
                    channels[data.chat.id].supergroupInfo = supergroupInfo;
                    channels[data.chat.id].zeroCount = 0
                    channels[data.chat.id].bIsDiscussion = false;
                    channels[data.chat.id].discussionChannel = null;

                    if (supergroup.has_linked_chat)
                    {
                        var discussionChat = await client.send({
                            '@type': 'getChat',
                            chat_id: supergroupInfo.linked_chat_id,
                        });
                        const discussionSupergroup = await client.send({
                            '@type': 'getSupergroup',
                            supergroup_id: discussionChat.type.supergroup_id,
                        });
                        const discussionSupergroupInfo = await client.send({
                            "@type": "getSupergroupFullInfo",
                            supergroup_id: discussionSupergroup.id,
                        });
                        channels[discussionChat.id] = {};
                        channels[discussionChat.id].title = discussionChat.title
                        channels[discussionChat.id].chat = discussionChat;
                        channels[discussionChat.id].supergroup = discussionSupergroup;
                        channels[discussionChat.id].supergroupInfo = discussionSupergroupInfo;
                        channels[discussionChat.id].zeroCount = 0
                        channels[discussionChat.id].bIsDiscussion = true;
                        channels[discussionChat.id].discussionChannel = null;
                        channels[discussionChat.id].discussionChannel = channels[discussionChat.id];
                        channels[data.chat.id].discussionChannel = channels[discussionChat.id];
                    }

                    if (current_status == status_home)
                    {
                        // load one thing form every channel
                        loadMessageFromChannel(data.chat);
                    }
                }

                if (supergroup.status["@type"] === 'chatMemberStatusCreator')
                {
                    // the "timeline" channel description ends with your user ID, so it can be found here.
                    // mmmm yes sneaking in metadata my beloved.

                    if (supergroupInfo.description.endsWith(user.id))
                    {
                        timelineChannel = data.chat
                    }
                }
            }
        }
    }

    var bAuthDone = false;
    // Called when auth is completed.
    function authorizationDone()
    {
        DOMhome.hidden = true;
        DOMchannel.hidden = true;
        DOMthread.hidden = true;

        current_status = status_home;
        if (channel_name_or_id)
        {
            current_status = status_channel

            if (channel_message_id)
                current_status = status_thread
        }
        if (current_status == status_home)
            DOMhome.hidden = false;
        if (current_status == status_channel)
            DOMchannel.hidden = false;
        if (current_status == status_thread)
            DOMthread.hidden = false;
    }
    let options =
    {
        logVerbosityLevel: 1,
        jsLogVerbosityLevel: 3,
        mode: 'wasm',
        prefix: 'tdlib',
        readOnly: false,
        isBackground: false,
        useDatabase: true,
        wasmUrl: `3dee0f934ca1a5946a253599e3e442c6.wasm`,
        onUpdate: update
    };

    var client = new tdweb.default(options)
</script>